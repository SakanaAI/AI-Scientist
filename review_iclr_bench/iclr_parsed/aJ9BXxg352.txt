# INTRIGUING PROPERTIES OF INPUT-DEPENDENT RANDOMIZED SMOOTHING

**Anonymous authors**
Paper under double-blind review

ABSTRACT

Randomized smoothing is currently considered the state-of-the-art method to obtain certifiably robust classifiers. Despite its remarkable performance, the method
is associated with various serious problems such as â€œcertified accuracy waterfallsâ€, certification vs. accuracy trade-off, or even fairness issues. Input-dependent
smoothing approaches have been proposed with intention of overcoming these
flaws. However, we demonstrate that these methods lack formal guarantees and
so the resulting certificates are not justified. We show that the input-dependent
smoothing, in general, suffers from the curse of dimensionality, forcing the variance function to have low semi-elasticity. On the other hand, we provide a theoretical and practical framework that enables the usage of input-dependent smoothing
even in the presence of the curse of dimensionality, under strict restrictions. We
present one concrete design of the smoothing variance and test it on CIFAR10 and
MNIST. Our design solves some of the problems of classical smoothing and is
formally underlined, yet further improvement of the design is still necessary.

1 INTRODUCTION

Deep neural networks are one of the dominating recently used machine learning methods. They
achieve state-of-the-art performance in a variety of applications like computer vision, natural language processing, and many others. The key property that makes neural networks so powerful is
their expressivity (GÂ¨uhring et al., 2020). However, as a prize, they possess a weakness - a vulnerability against adversarial attacks (Szegedy et al., 2013; Biggio et al., 2013). The adversarial attack
on a sample x is a point x[â€²] such that the distance d(x[â€²], x) is small, yet the model f â€™s predictions on
_x and x[â€²]_ differ. Such examples are often easy to construct, for example by optimizing for a change
in prediction f (x) (Biggio et al., 2013). Even worse, these attacks are present even if the modelâ€™s
prediction on x is unequivocal.

This property is highly undesirable because in several sensitive applications, misclassifying a sample just because it does not follow the natural distribution might lead to serious and harmful consequences. A well-known example would be a sticker placed on a traffic sign, which could possibly
confuse the self-driving car and cause an accident (Eykholt et al., 2018). To prevent this behaviour,
the robustness of classifiers against adversarial examples has begun to be a strongly discussed topic.
Though many methods claim to provide robust classifiers, just some of them are certifiably robust,
i.e. the robustness is mathematically guaranteed. The certifiability turns out to be essential since
more sophisticated attacks can break empirical defenses (Carlini & Wagner, 2017).

Currently, the dominating method to achieve the certifiable robustness is randomized smoothing
(RS). This clever idea to get rid of adversarial examples using randomization of input was introduced
by Lecuyer et al. (2019) and Li et al. (2019) and fully formalized and improved in Cohen et al.
(2019). Let f be a classifier classifying inputs x âˆˆ R[N] as one of the classes C âˆˆC. Assume
now a random deviation Ïµ âˆ¼N (0, Ïƒ[2]I). The smoothed classifier g, made of f, is defined as:
_g(x) = arg maxC P(f_ (x + Ïµ) = C), for C âˆˆC. In other words, the smoothed classifier classifies a
class that has the highest probability under the sampling of f (x + Ïµ). Consequently, an adversarial
attack x[â€²] on f is less dangerous for g, because g does not look directly at x[â€²], but rather at its whole
neighborhood, in a weighted manner. This way, we can get rid of local artifacts that f possesses â€“
thus the name â€œsmoothingâ€. It turns out, that g enjoys strong robustness properties against attacks


-----

bounded by a specifically computed l2-norm threshold, especially if f is trained under a Gaussian
noise augmentation (Cohen et al., 2019).

Unfortunately, since the introduction of the RS, several serious problems were reported to be connected to the technique. Cohen et al. (2019) mention two of them. First is the usage of lower
confidence bounds to estimate the leading classâ€™s probability. With a high probability, this leads to
smaller reported certified radiuses in comparison with the true ones. Moreover, it yields a theoretical threshold, which upper-bounds the maximal possible certified radius and causes the â€œcertified
accuracy waterfallsâ€, significantly decreasing the certified accuracy. This problem is particularly
pronounced for small levels of the used smoothing variance Ïƒ[2], which motivates to use larger variance. Second, RS possesses a robustness vs. accuracy trade-off problem. The bigger Ïƒ we use as the
smoothing variance, the smaller clean accuracy will the smoothed classifier have. This motivates to
use rather smaller levels of Ïƒ. Third, as pointed out by Mohapatra et al. (2020a), RS smoothens the
decision boundary of f in such a way, that bounded or convex regions begin to shrink as Ïƒ increases,
while the unbounded and anti-convex regions expand. This, as the authors empirically demonstrate,
creates a disbalance in class-wise accuracies of g and causes serious fairness issues. Therefore,
again, the smaller values of Ïƒ are more preferable. See Appendix A for a detailed discussion.

Clearly, the usage of a global, constant Ïƒ is suboptimal. For the samples close to the decision boundary, we want to use small Ïƒ, so that f and g have similar decision boundaries and the expressivity
of f is not lost (where not necessary). On the other hand, far from the decision boundary of f,
where the probability of the dominant class is close to 1, we need bigger Ïƒ to avoid the severe
under-certification (see Appendix A). Together, using a non-constant Ïƒ(x) rather than constant Ïƒ, a
suitable smoothing variance could be used to achieve optimal robustness. Yet there are some works
introducing this concept (see Appendix C), most of them lack mathematical reasoning about the
correctness of their method, which, as we show, turns out to be critical.

To support this argumentation, we present a toy example. We train a network on a 2D dataset of a
circular shape with the classes being two complementary sectors, where one is of a very small angle.
In Figure 1 we show the difference between constant and input-dependent Ïƒ. Using non-constant
_Ïƒ(x) defined in Equation 1, we obtain an improvement both in terms of the certified radiuses as well_
as clean accuracy. For more details see Appendix A.

Figure 1: Motivating toy experiment. The constant Ïƒ = 0.6 and the input-dependent Ïƒ(x) equal
in average to the constant Ïƒ are used. Left: Dataset and the variance function depicted as circles
with the radius equal to Ïƒ(x) and centers at the data points. Middle: Zoomed in part of the dataset
and decision boundaries of the smoothed classifiers with constant Ïƒ (red) and input-dependent Ïƒ(x)
(green). Note that we recover a part of the misclassified data points by using a more appropriate
smoothing strength close to the decision boundary. Right: Certified accuracy plot. The waterfall
effect vanishes since the points far from the decision boundary are certified with a correspondingly
large Ïƒ(x).

The main contributions of this work are fourfold. First, we generalize the methodology of Cohen
et al. (2019)â€™s work for the case of input-dependent RS (IDRS), obtaining useful and important
insights about how to use the Neyman-Pearson lemma in this, general, case. Second and most
importantly, we show that the IDRS suffers from the curse of dimensionality in the sense that the
in a high-dimensional setting is restricted to be very small. This means, that even if we wanted tosemi-elasticity coefficient r of Ïƒ(x) (that is | log(Ïƒ(x0))âˆ’log(Ïƒ(x1))| â‰¤ _râˆ¥x0âˆ’x1âˆ¥âˆ€x0, x1 âˆˆ_ R[N] )
vary the Ïƒ(x) significantly with varying x, we canâ€™t. The maximal reasonable speed of change of
_Ïƒ(x) turns out to be almost too small to handle, especially in high dimensions. Third, in contrast,_


-----

we also study the conditions on Ïƒ(x) under which it is applicable in high-dimensional regime and
prepare a theoretical framework necessary to build an efficient certification algorithm. We are the
first to do so for Ïƒ(x) functions, which are not locally constant (as in Wang et al. (2021)). Finally, we
provide a concrete design of the Ïƒ(x) function and test it extensively and compare it to the classical
RS on the CIFAR10 and MNIST datasets. We discuss to what extent the method treats the issues
mentioned above.

2 INPUT-DEPENDENT RS AND THE CURSE OF DIMENSIONALITY

Let C be the set of classes, f : R[N] _âˆ’â†’C a classifier (reffered to as the base classifier), Ïƒ : R[N]_ _âˆ’â†’_ R
a non-negative function and P(C) a set of distributions over C. Then we call Gf : R[N] _âˆ’â†’P(C) the_
_smoothed class probability predictor, if Gf_ (x)C = P(f (x + Ïµ) = C), where Ïµ âˆ¼N (0, Ïƒ(x)[2]I)
and gf : R[N] is called smoothed classifier if gf (x) = arg maxC Gf (x)C, for C . We will
_âˆ’â†’C_ _âˆˆC_
omit the subscript f in gf often, since it is usually clear from the context, to which base classifier
the g corresponds. Furthermore, let A := g(x) refer to the most likely class under the random
variable f (N (x, Ïƒ[2]I)), while B denote the second most likely class. Define pA = Gf (x)A and
_pB = Gf_ (x)B as the respective probabilities. It is important to note that in practice, it is impossible
to estimate pA and pB precisely. Instead, pA is estimated as a lower confidence bound (LCB) of the
relative occurence of class A in f â€™s predictions given certain number of Monte-Carlo samples n and
a confidence level Î± and the estimate is denoted as pA. We use the exact Clopper-Pearson interval
for estimation of the LCB. Similarly for pB. We work with l2-norms denoted as _x_ .
_âˆ¥_ _âˆ¥_

First of all, we summarize the main steps in the derivation of certified radius using any method that
relies on a use of Neyman-Pearson lemma.

1. For a potential adversary _x[â€²]_ specify the _worst-case_ classifier _f_ _[âˆ—],_ such that
P(f _[âˆ—](N_ (x, Ïƒ[2]I)) = A) = pA, while P(f _[âˆ—](N_ (x[â€²], Ïƒ[2]I)) = B) is maximized.

2. Express the probability Gf âˆ— (x[â€²])B as a function depending on x[â€²].
3. Determine the conditions on x[â€²] (possibly related to âˆ¥x âˆ’ _x[â€²]âˆ¥) for which this probability is_
_â‰¤_ 0.5. From these condtions, derive the certified radius.


Cohen et al. (2019) proceeded in this way to obtain a tight certified radius R = _Ïƒ2_ [(Î¦][âˆ’][1][(][p][A][)][ âˆ’]
Î¦[âˆ’][1](pB)). Unfortunately, their result is not directly applicable to the input-dependent case. The
constant Ïƒ simplifies the derivation of f _[âˆ—]_ that turns out to be a linear classifier. This is not the case
for non-constant Ïƒ(x) anymore. Therefore, we need to generalize the methodology of Cohen et al.
(2019). We put pB = 1âˆ’pA for simplicity (yet it is not necessary to assume this, see Appendix B.5).
Let x0 be the point to certify, x1 the potential adversary point, Î´ = x1âˆ’x0 the noise and Ïƒ0 = Ïƒ(x0),
_Ïƒ1 = Ïƒ(x1) the standard deviations used in x0 and x1 respectively. Furthermore, let fi be a density_
and Pi a probability measure corresponding to N (xi, Ïƒi[2][I][)][,][ i][ âˆˆ{][0][,][ 1][}][.]

**Lemma 1. Out of all possible classifiers f such that Gf** (x)B _pB = 1_ _pA, the one, for which_
_Gf_ (x + Î´)B is maximized is the one, which predicts class B in a region determined by the likelihood â‰¤ _âˆ’_
ratio:

_B =_ _x_ R[N] : _[f][1][(][x][)]_ _,_
_âˆˆ_ _f0(x)_ _r_
 _[â‰¥]_ [1] 

where r is fixed, such that P0(B) = pB. Note, that we use B to denote both the class and the region
of that class.

We use this lemma to compute the decision boundary of the worst-case classifier f _[âˆ—]._
**Theorem 2. If Ïƒ0 > Ïƒ1, then B is a N** -dimensional ball with the center at S> and radius R>:


_S> = x +_ _Ïƒ0[2]_ _Î´, R> =_ _Ïƒ0[2][Ïƒ]1[2]_ _Ïƒ0[2][Ïƒ]1[2]_ log _Ïƒ0_ + [2][Ïƒ]0[2][Ïƒ]1[2] log(r).

_Ïƒ0[2]_ 1 s (Ïƒ0[2] 1[)][2][ âˆ¥][Î´][âˆ¥][2][ + 2][N] _Ïƒ0[2]_ 1 _Ïƒ1_ _Ïƒ0[2]_ 1

 

_[âˆ’]_ _[Ïƒ][2]_ _[âˆ’]_ _[Ïƒ][2]_ _[âˆ’]_ _[Ïƒ][2]_ _[âˆ’]_ _[Ïƒ][2]_

If Ïƒ0 < Ïƒ1, then B is the complement of a N -dimensional ball with the center at S< and radius R<:


2Ïƒ0[4] _[âˆ’]_ _[Ïƒ]0[2][Ïƒ]1[2]_ _Ïƒ0[2][Ïƒ]1[2]_ log _Ïƒ1_

(Ïƒ1[2] 0[)][2][ âˆ¥][Î´][âˆ¥][2][ + 2][N] _Ïƒ1[2]_ 0 _Ïƒ0_



_[âˆ’]_ _[Ïƒ][2]_ _[âˆ’]_ _[Ïƒ][2]_


_S< = x_ _Ïƒ0[2]_ _Î´, R< =_
_âˆ’_ _Ïƒ1[2]_ 0

_[âˆ’]_ _[Ïƒ][2]_


0[Ïƒ]1[2] log(r).
_âˆ’_ _Ïƒ[2]1[2][Ïƒ][2]_ 0

_[âˆ’]_ _[Ïƒ][2]_


-----

Figure 2: Decision regions of the worst-case classifier f _[âˆ—]. Left: Ïƒ0 > Ïƒ1 Right: Ïƒ0 < Ïƒ1_

As we depict on Figure 2, both resulting balls are centered on the line connecting x0, x1. Moreover,
the centers of the balls are always further from x0, than x1 is from x0 (even in the case Ïƒ0 < Ïƒ1).
In both cases, it depends on pA (since r is fixed such that P0(B) = pB) and the ball can, but might
not cover x0 and/or x1. Note that if Ïƒ0 = Ïƒ1, what can happen even in input-dependent regime, the
worst-case classifier is the half-space described by Cohen et al. (2019).

To compute the probability of a ball under a probability measure with an isotropic Gaussian density
is far more challenging than to compute the probability of a half-space. In fact, there is no closedform formula for such probability. However, this probability is connected to the non-central chisquare distribution (NCCHSQ). More precisely, the probability of an N -dimensional ball centered
at z with radius r under N (0, I) can be expressed as a cumulative distribution fucntion (cdf) of
NCCHSQ with N degrees of freedom, non-centrality parameter âˆ¥zâˆ¥[2] and argument r[2]. With this
knowledge, we can express P0(B) and P1(B) in terms of the cdf of NCCHSQ as follows.
**Theorem 3.**

P0(B) = Ï‡[2]N (Ïƒ0[2] _Ïƒ0[2]_ 1[)][2][ âˆ¥][Î´][âˆ¥][2][, R]Ïƒ<,>[2]0[2] ! _, P1(B) = Ï‡[2]N_ (Ïƒ0[2] _Ïƒ1[2]_ 1[)][2][ âˆ¥][Î´][âˆ¥][2][, R]Ïƒ<,>[2]1[2] ! _,_

_[âˆ’]_ _[Ïƒ][2]_ _[âˆ’]_ _[Ïƒ][2]_

where the sign < or > is chosen according to the inequality between Ïƒ0 and Ïƒ1.


Note, that both Theorem 2 and Theorem 3 work well also for Î´ = 0. In this case, we encounter a
ball centered at x0 = x1 and all the cdf functions become cdf functions of central chi-squared.

We expressed probabilities of the worst-case class Bâ€™s decision region using the cdf of NCCHCSQ.
Now, how do we do the certification? We start with the certification just for two points, x0 and x1.
We question, under which circumstances can x1 be certified from the point of view of x0. Having x0,
_pA and Ïƒ0 > Ïƒ1, we can obtain such R, that P0(B) = Ï‡[2]N_ _Î´_ _Ïƒ0[2][/][(][Ïƒ]0[2]_ 1[)][2][, R][2][] = 1 _pA =_
_âˆ¥_ _âˆ¥[2]_ _[âˆ’]_ _[Ïƒ][2]_ _âˆ’_
_pB simply by putting it into the quantile function: R[2]_ = Ï‡[2]N,qf _Î´_ _Ïƒ0[2][/][(][Ïƒ]0[2]_ 1[)][2][,][ 1][ âˆ’] _[p][A]_ . Then,
  _âˆ¥_ _âˆ¥[2]_ _[âˆ’]_ _[Ïƒ][2]_
we can substitute into P1(B) = Ï‡[2]N _Î´_ _Ïƒ1[2][/][(][Ïƒ]0[2]_ 1[)][2][, R][2][Ïƒ]0[2][/Ïƒ]1[2] . This way, we obtain P1(B)
and can judge, whether P1(B) < 1/2 or not. Similar computation can be done ifâˆ¥ _âˆ¥[2]_ _[âˆ’]_ _[Ïƒ][2]_   _Ïƒ0 < Ïƒ1. Denote_
  
_a := âˆ¥Î´âˆ¥. We can express the P1(B) more simply for Ïƒ0 > Ïƒ1 as_

_Î¾>(a) := P1(B) = Ï‡[2]N_ (Ïƒ0[2] _Ïƒ1[2]_ 1[)][2][ a][2][, Ïƒ]Ïƒ10[2][2] _Ï‡[2]N,qf_ (Ïƒ0[2] _Ïƒ0[2]_ 1[)][2][ a][2][,][ 1][ âˆ’] _[p][A]_

  

_[âˆ’]_ _[Ïƒ][2]_ _[âˆ’]_ _[Ïƒ][2]_

and for Ïƒ0 < Ïƒ1 as

_Î¾<(a) := P1(B) = 1 âˆ’_ _Ï‡[2]N_ (Ïƒ1[2] _Ïƒ1[2]_ 0[)][2][ a][2][, Ïƒ]Ïƒ01[2][2] _Ï‡[2]N,qf_ (Ïƒ1[2] _Ïƒ0[2]_ 0[)][2][ a][2][, p][A] _._

  

_[âˆ’]_ _[Ïƒ][2]_ _[âˆ’]_ _[Ïƒ][2]_

With this in mind, if we have x0, x1, pA, Ïƒ0, Ïƒ1, then we can certify x1 w.r.t x0 simply by choosing
the correct sign (<, >) and computing Î¾<( _x0_ _x1_ ) or Î¾>( _x0_ _x1_ ), comparing them with 0.5.
The sample plots of these Î¾ functions can be found in Appendix B.âˆ¥ _âˆ’_ _âˆ¥_ _âˆ¥_ _âˆ’_ _âˆ¥_

Now, we are ready to discuss the curse of dimensionality. The problem that arises is that having a
high dimension N and Ïƒ0, Ïƒ1 differing a lot from each other, Î¾ functions are already big at 0, even


-----

Figure 3: Plots depicting tightness of results of Theorem 4. On both figures, the biggest possible
threshold of Ïƒ1/Ïƒ0 for which the condition in Theorem 4 is satisfied (theoretical threshold) and the
numerically computed threshold for which Î¾>(0) passes the threshold 0.5 (practical threshold) are
depicted. Left: Plot for pA = 0.9, Right: Plot for pA = 0.999.

for considerably small pB. For fixed ratio Ïƒ0/Ïƒ1 and probability pB, with increasing dimension, the
_Î¾(0) increases and soon becomes bigger than 0.5. This, together with monotonicity of Î¾ function_
yields that any x1 cannot be certified w.r.t. x0, if Ïƒ0, Ïƒ1 are used. The more dissimilar the Ïƒ0 and Ïƒ1
are, the smaller the dimension N needs to be for this situation to occur. If we want to certify x1 in
a reasonable distance from x0, we need to use similar Ïƒ0, Ïƒ1. This restricts the variability of Ïƒ(x)
function. We will formalize the curse of dimensionality in the following theorems. More on why
the curse of dimensionality is present is in Appendix B.2.
**Theorem 4 (curse of dimensionality). Let x0, x1, pA, Ïƒ0, Ïƒ1, N be as usual. Then, the following**
two implications hold:


1. If Ïƒ0 > Ïƒ1 and

log _Ïƒ12_

_Ïƒ0[2]_



then x1 is not certified w.r.t. x0.


+ 1 1 _<_ [2 log(1][ âˆ’] _[p][A][)]_
_âˆ’_ _[Ïƒ]Ïƒ0[2][2]_ _N_


2. If Ïƒ0 < Ïƒ1 and

log _Ïƒ12_ _N âˆ’_ 1 + 1 1 _N âˆ’_ 1 _<_ [2 log(1][ âˆ’] _[p][A][)]_ _,_

_Ïƒ0[2]_ _N_ _âˆ’_ _[Ïƒ]Ïƒ0[2][2]_ _N_ _N_

 

then x1 is not certified w.r.t. x0.

**Corollary 5 (one-sided simpler bound). Let x0, x1, pA, Ïƒ0, Ïƒ1, N be as usual and assume now Ïƒ0 >**
_Ïƒ1. Then, if_


_Ïƒ1_
_Ïƒ0_


log(1 _pA)_
_âˆ’_ _âˆ’_


1 âˆ’ 2


then x1 is not certified w.r.t x0.


Note, that both Theorem 4 and Corrolary 5 can be adjusted to the case where we have a separate
estimate pB and do not put pB = 1 âˆ’ _pA (see Appendix B.5). We must emphasize, that the bounds_
obtained in Theorem 4 are very tight. In other words, if the ratio _[Ïƒ]Ïƒ[1]0_ [is just slightly bigger than the]

minimal possible threshold determined in Theorem 4, Î¾>(0) becomes smaller than 0.5 and similarly
for Î¾>(0). The reason for this is, that the only two estimates used in the proof of Theorem 4 are
the estimates on the median, which are very tight and constant with respect to N and the Chernoff
bound, which is generally considered to be tight too and improves for larger N . The tightness is
depicted on Figure 3, where we plot the minimal possible threshold Ïƒ1/Ïƒ0 given by Theorem 4 and
minimal threshold for which Î¾>(0) < 0.5 as a function of N .

To get a better feeling about the concrete numbers, we provide a simple table, which shows the
theoretical threshold values provided by Theorem 4. If Ïƒ1/Ïƒ0 is smaller than the threshold, we are
not able to certify any pair of x0, x1 using Ïƒ0, Ïƒ1.


-----

|p A|0.9|0.99|0.999|0.99993|
|---|---|---|---|---|
|MNIST|0.946|0.924|0.908|0.892|
|CIFAR10|0.973|0.961|0.953|0.945|
|ImageNet|0.997|0.995|0.994|0.993|


_pA_ 0.9 0.99 0.999 0.99993

MNIST 0.946 0.924 0.908 0.892

CIFAR10 0.973 0.961 0.953 0.945

ImageNet 0.997 0.995 0.994 0.993


Table 1: Theoretical lower-thresholds for Ïƒ1/Ïƒ0 for different data dimensions and class A probabilities. The ImageNet spatial size is assumed to be 3x256x256.

Results from Table 1 are very restrictive. Assume we have a CIFAR10 sample with pA = 0.999.
For such a probability, constant Ïƒ = 0.5 is more than sufficient to guarantee the certified radius of
more than 1. However, in the non-constant regime, to certify R â‰¥ 1, we first need to guarantee that
_no sample within the distance of 1 from x0 uses Ïƒ1 < 0.953Ïƒ0. To even strengthen this statement,_
note that one needs to guarantee Ïƒ1 to be even much closer to Ïƒ0 in practice. Why? The results of
Theorem 4 lower-bound the Î¾ functions at 0. However, since Î¾ functions are strictly increasing (as
shown in Appendix F), one usually needs Ïƒ0 and Ïƒ1 to be much closer to each other to guarantee Î¾
being smaller than 0.5 at a â‰« 0. This not only forces the Ïƒ(x) function to have really small semielasticity but also makes it problematic to define a stochastic Ïƒ(x). For more, see Appendix B.2.

To fully understand, how the curse of dimensionality affects the usage of IDRS, we mention two
more significant effects. First, with increasing dimension, the average distance between samples
tends to grow as _âˆšN_ . This enables bigger distance to change Ïƒ(x). On the other hand, the average

level of Ïƒ(x) used (like âˆ¼ 0.12, 0.25, . . . ) needs to be adjusted also as _âˆšN with increasing dimen-_

sion. The bigger average level of Ïƒ(x) we use, the more is the semi-elasticity of Ïƒ(x) restricted by
Theorem 4 and Theorem 7. All together, these two effects combine in a final trend that for Ïƒ0 and
_ÏƒFor detailed explanation, see Appendix B.4.1 being variances used in two random test samples, |Ïƒ0/Ïƒ1 âˆ’_ 1| is restricted to go to 0 as 1/âˆšN.

3 HOW TO USE INPUT-DEPENDENT SMOOTHING PROPERLY

As we discuss above, usage of IDRS is challenging. How can we use Ïƒ(x) and obtain valid, mathematically justified certified radiuses? Fix some design Ïƒ(x). If Ïƒ(x) is not trivial, to obtain a
certified radius at x0, we need to go over all the possible adversaries x1 in the neighborhood of x0,
_xcompute1 points. Of course, this is a priori infeasible. Fortunately, the Ïƒ1 and Î¾<,>(a). Then, the certified radius is the infimum over Î¾ functions possess a property that âˆ¥x0 âˆ’_ _x1âˆ¥_ for all uncertified
helps to simplify this procedure. For convenience, we extend the notation of Î¾ functions such that
_Î¾(a, Ïƒ1) additionally denotes the dependance on the Ïƒ1 value._
**Theorem 6.statements hold: Let x0, x1, pA, Ïƒ0 be as usual and let âˆ¥x0 âˆ’** _x1âˆ¥_ = R. Then, the following two

1. Let Ïƒ1 â‰¤ _Ïƒ0. Then, for all Ïƒ2 : Ïƒ1 â‰¤_ _Ïƒ2 â‰¤_ _Ïƒ0, if Î¾>(R, Ïƒ2) > 0.5, then Î¾>(R, Ïƒ1) > 0.5._

2. Let Ïƒ1 â‰¥ _Ïƒ0. Then, for all Ïƒ2 : Ïƒ1 â‰¥_ _Ïƒ2 â‰¥_ _Ïƒ0, if Î¾<(R, Ïƒ2) > 0.5, then Î¾<(R, Ïƒ1) > 0.5._

Theorem 6 serves as a kind of monotonicity property. The main gain is that now, for each distance
_R from x0, we need to pick just two adversaries â€“ the one with biggest Ïƒ1 (if bigger than Ïƒ0) and_
the one with the smallest Ïƒ1 (if smaller than Ïƒ0). If we cannot certify some point x1 at the distance
_R from x0, then we will for sure not be able to certify at least one of the two adversaries with the_
most extreme Ïƒ1 values.

This does, however, not suffice for most of the reasonable Ïƒ(x) designs, since it might be still too
hard to determine the two most extreme Ïƒ1â€™s at some distance from x0. Therefore, we need to
assume that our Ïƒ(x) has a bounded semi-elasticity coefficient r. Then we have a guarantee that
_Ïƒ(x0) exp(_ _ra)_ _Ïƒ(x1)_ _Ïƒ(x0) exp(ra). Thus, we can assume the worst-case extreme Ïƒ1â€™s for_
_âˆ’_ _â‰¤_ _â‰¤_
every distance a from x0. Using this, we guarantee the following certified radius.
**Theorem 7. Let Ïƒ(x) be r-semi-elastic function and x0, pA, N, Ïƒ0 as usual. Then, the certified**
radius at x0 guaranteed by our method is

CR(x0) = max {0, sup {R â‰¥ 0; Î¾>(R, Ïƒ0 exp(âˆ’rR)) < 0.5 and Î¾<(R, Ïƒ0 exp(rR)) < 0.5}} .


-----

Note that Theorem 7 can be adjusted to the case where we have a separate estimate pB and do not
put pB = 1 âˆ’ _pA (see Appendix B.5). Since the bigger the semi-elasticity constant of Ïƒ(x) is, the_
worse certifications we obtain, it is important to estimate the constant tightly. Even with a good
estimate of r, we still get smaller certified radiuses in comparison with using the Ïƒ(x) exactly, but
that is a prize that is inevitable for the feasibility of the method.

The practical algorithm is then very easy - we just need to pick sufficiently dense space of possible
radiuses and determine the smallest, for which either Î¾>(R, Ïƒ0 exp(âˆ’rR)) or Î¾<(R, Ïƒ0 exp(rR))
becomes bigger than a half. The only non-trivial part is, how to evaluate the Î¾ functions. For small
values of R, the exp(âˆ’rR) is very close to 1 and from the definition of Î¾ functions it is obvious
that this results in extremely big inputs to the cdf and quantile function of NCCHSQ. To avoid
numerical problems, we employ a simple hack where we assume thresholds for Ïƒ1 such that for
_R small enough, these thresholds are used instead of Ïƒ0 exp(Â±rR)). Unfortunately, the numerical_
stability still disables the usage of this method on really high-dimensional datasets like ImageNet.
For more details on implementation, see Appendix D.

4 THE DESIGN OF Ïƒ(x) AND EXPERIMENTS

The only missing ingredient to finally being able to use IDRS is the Ïƒ(x) function. As we have seen,
this function has to be r-semi-elastic for rather small r and ideally deterministic. Yet it should at
least roughly fulfill the requirements imposed by the motivation â€“ it should possess big values for
points far from the decision boundary of f and rather small for points close to it. Adhering to these
restrictions, we use the following function:

_Ïƒ(x) = Ïƒb exp_ _r_ _x_ _xi_ _m_ _,_ (1)

ï£« ï£« _k_ ï£« _âˆ¥_ _âˆ’_ _âˆ¥ï£¶_ _âˆ’_ ï£¶ï£¶

_xiâˆˆNXk(x)_

ï£­ ï£­ [1] ï£­ ï£¸ ï£¸ï£¸

for Ïƒb being a base standard deviation, r being the required semi-elasticity, {xi}i[d]=1 [the training set,]
_k(x) the k nearest neighbors of x and m the normalization constant. Intuitively, if a sample is far_
_N_
from all other samples, it will be far from the decision boundary, unless the network overfits to this
sample. On the other hand, the dense clusters of samples are more likely to be positioned near the
decision boundary, since such clusters have a high leverage on the networkâ€™s weights, forcing the
decision boundary to adapt well to the geometry of the cluster. To use such a function, however, we
first prove that it is indeed r-semi-elastic.
**Theorem 8. The Ïƒ(x) defined in equation 1 is r-semi-elastic.**

We test our IDRS and our Ïƒ(x) functions extensively. For both CIFAR10 (Krizhevsky, 2009) and
MNIST (LeCun et al., 1999) datasets, we analyze series of different experimental setups, including
experiments with an input-dependent train-time Gaussian data augmentation. We present a direct
comparison of our method with the constant Ïƒ method using evaluation strategy from Cohen et al.
(2019) (all other experiments, including ablation studies, and the discussion on the hyperparameter
selection are presented in Appendix E). Here, we compare Cohen et al. (2019)â€™s evaluations for
_Ïƒ = 0.12, 0.25, 0.50 with our evaluations, setting Ïƒb = Ïƒ, r = 0.01, k = 20, m = 5, 1.5 (for_
CIFAR10 and MNIST, respectively), applied on models trained with Gaussian data augmentation,
using constant standard deviation roughly equal to the average test-time Ïƒ(x) or test-time Ïƒ. For
CIFAR10, these levels of train-time standard deviation are Ïƒtr = 0.126, 0.263, 0.53 and for MNIST
_Ïƒtr = 0.124, 0.258, 0.517. In this way, the levels of Ïƒ(x) we use in the direct comparison are spread_
from the values roughly equal to Cohen et al. (2019)â€™s constant Ïƒ to higher values. The results are
depicted in Figure 4.

From Figure 4 we see that we outperform the constant Ïƒ for small levels of Ïƒ, such as 0.12 or 0.25.
On higher levels of Ïƒ, we are, in general, worse (see explanation in Appendix B.3). The most visible
improvement is in mitigation of the truncation of certified accuracy (certified accuracy waterfall).
To comment on the other two issues, we provide Tables 2 and 3 with the clean accuracies and classwise accuracy standard deviations. These results are averages of 8 independent runs and in Table 2,
the displayed error values are equal to empirical standard deviations.

From Tables 2 and 3, we draw two conclusions - first, it is not easy to judge about the robustness
vs. accuracy trade-off, because the differences in clean accuracies are not statistically significant in


-----

Figure 4: Comparison of certified accuracy plots for Cohen et al. (2019) and our work.

|Col1|dataset|Ïƒ = 0.12|Ïƒ = 0.25|Ïƒ = 0.50|
|---|---|---|---|---|
|r = 0.01, Ïƒ increased tr|C|0.852 0.002 Â±|0.780 0.013 Â±|0.673 0.008 Â±|
|r = 0.00|C|0.851 0.006 Â±|0.792 0.004 Â±|0.674 0.018 Â±|
|r = 0.01, Ïƒ increased tr|M|0.9912 0.0003 Â±|0.9910 0.0006 Â±|0.9881 0.0003 Â±|
|r = 0.00|M|0.9914 0.0004 Â±|0.9907 0.0004 Â±|0.9886 0.0005 Â±|


dataset _Ïƒ = 0.12_ _Ïƒ = 0.25_ _Ïƒ = 0.50_

_r = 0.01, Ïƒtr increased_ C 0.852 Â± 0.002 0.780 Â± 0.013 0.673 Â± 0.008

_r = 0.00_ C 0.851 Â± 0.006 0.792 Â± 0.004 0.674 Â± 0.018

_r = 0.01, Ïƒtr increased_ M 0.9912 Â± 0.0003 0.9910 Â± 0.0006 0.9881 Â± 0.0003

_r = 0.00_ M 0.9914 Â± 0.0004 0.9907 Â± 0.0004 0.9886 Â± 0.0005


Table 2: Clean accuracies for both input-dependent and constant Ïƒ evaluation strategies on CIFAR10
(C) and MNIST (M).

|Col1|dataset|Ïƒ = 0.12|Ïƒ = 0.25|Ïƒ = 0.50|
|---|---|---|---|---|
|r = 0.01, Ïƒ increased tr|C|0.076|0.099|0.120|
|r = 0.00|C|0.076|0.097|0.122|
|r = 0.01, Ïƒ increased tr|M|0.00775|0.00777|0.00930|
|r = 0.00|M|0.00751|0.00778|0.00934|


dataset _Ïƒ = 0.12_ _Ïƒ = 0.25_ _Ïƒ = 0.50_

_r = 0.01, Ïƒtr increased_ C 0.076 0.099 0.120

_r = 0.00_ C 0.076 0.097 0.122

_r = 0.01, Ïƒtr increased_ M 0.00775 0.00777 0.00930

_r = 0.00_ M 0.00751 0.00778 0.00934


Table 3: Class-wise accuracy standard deviations for both input-dependent and constant Ïƒ evaluation
strategies on CIFAR10 (C) and MNIST (M).

any of the experiments (not even for CIFAR10 and Ïƒ = 0.25, where the difference is at least pronounced). However, the general trend in Table 2 indicates that the clean accuracies tend to slightly
decrease with increasing rate. Nevertheless, the differences are not large enough to compensate
negatively the fact that we outperform constant Ïƒ in terms of the certified accuracies. Second, the
standard deviations of the class-wise accuracies, which serve as a good measure of the impact of
the shrinking phenomenon and subsequent fairness, donâ€™t significantly change after applying the
non-constant RS.

5 RELATED WORK

Since the vulnerability of deep neural networks against adversarial attacks has been noticed by
Szegedy et al. (2013); Biggio et al. (2013) a lot of effort has been put into making neural nets
more robust. There are two types of solutions â€“ empirical and certified defenses. While empirical
defenses suggest heuristics to make models robust, certified approaches additionally provide a way
to compute a mathematically valid robust radius.


-----

One of the most effective empirical defenses, adversarial training (Goodfellow et al., 2014; Kurakin
et al., 2016; Madry et al., 2017), is based on a very intuitive idea to use adversarial examples for
training. Unfortunately, together with adversarial training, other promising empirical defenses were
subsequently broken by more sophisticated adversarial methods (for instance Carlini & Wagner
(2017); Athalye & Carlini (2018); Athalye et al. (2018), among many others).

Among many certified defenses (Tsuzuku et al., 2018; Anil et al., 2019; Hein & Andriushchenko,
2017; Wong & Kolter, 2018; Raghunathan et al., 2018; Mirman et al., 2018; Weng et al., 2018),
one of the most successful yet is RS. While Lecuyer et al. (2019) introduced the method within
the context of differential privacy, Li et al. (2019) proceeded via the knowledge of RÂ´enyi divergences. Possibly the most prominent work on RS is that of Cohen et al. (2019), where authors fully
established RS and proved tight certification guarantees.

Later, a lot of authors further worked with RS. The work of Yang et al. (2020) generalizes the certification provided by Cohen et al. (2019), to certifications with respect to the general lp norms and
provide the optimal smoothing distributions for each of the norms. Other works point out different problems or weaknesses of RS like the curse of dimensionality (Kumar et al., 2020; Hayes,
2020; Wu et al., 2021), robustness vs. accuracy trade-off (Gao et al., 2020) or a shrinking phenomenon(Mohapatra et al., 2020a), which yields serious fairness issues (Mohapatra et al., 2020a).

The work of Mohapatra et al. (2020b) improves RS further by introducing the first-order information
about g. In this work, authors not only estimate g(x), but also âˆ‡g(x), making more restrictions on
the possible base models f that might have created g. Zhai et al. (2020) and Salman et al. (2019)
improve the training procedure of f to yield better robustness guarantees of g. Salman et al. (2019)
directly use adversarial training of the base classifier f . Finally, Zhai et al. (2020) introduce socalled soft smoothing, which enables to compute gradients directly for g and construct a training
method, which optimizes directly for the robustness of g via the gradient descent.

To address several issues connected to randomized smoothing, there have been already four works
that introduce the usage of IDRS. Wang et al. (2021) divide R[N] into several regions Ri, i âˆˆ
_{1, . . ., K} and optimize for Ïƒi, i âˆˆ{1, . . ., K} locally, such that Ïƒi is a most suitable choice_
for the region Ri. Yet this work partially solves some problems of randomized smoothing, it also
possesses some practical and philosophical issues (see Appendix C). Alfarra et al. (2020); Eiras et al.
(2021); Chen et al. (2021), suggest to optimize for locally optimal Ïƒi, for each sample xi from the
test set. A similar strategy is proposed by these works in the training phase, with the intention of
obtaining the base model f that is most suitable for the construction of the smoothed classifier g.
They demonstrate, that by using this input-dependent approach, one can overcome some of the main
problems of randomized smoothing. However, as we demonstrate in Appendix C, their methodology
is not valid and therefore their results are not trustworthy.

6 CONCLUSIONS

We show in this work that input-dependent randomized smoothing suffers from the curse of dimensionality. In the high-dimensional regime, the usage of input-dependent Ïƒ(x) is being put under
strict constraints. The Ïƒ(x) function is forced to have very small semi-elasticity. This is in conflict with some recent works, which have used the input-dependent randomized smoothing without
mathematical justification and therefore claim invalid results. It seems that input-dependent randomized smoothing has limited potential of improvement over the classical, constant-Ïƒ RS. Moreover,
due to numerical instability, the computation of certified radiuses on high-dimensional datasets like
ImageNet remains to be an open challenge.

On the other hand, we prepare a ready-to-use mathematically underlined framework for the usage
of the input-dependent RS and show, that it works well for small to medium-sized problems. We
also show via extensive experiments, that our concrete design of the Ïƒ(x) function reasonably treats
the truncation issue connected to constant-Ïƒ RS and is partially capable of mitigating the robustness vs. accuracy one. The most intriguing and promising direction for the future work lies in the
development of new Ïƒ(x) functions, which are capable of even better treatment of the mentioned
issues.


-----

7 REPRODUCIBILITY STATEMENT

Both our theoretical and practical results and experiments are reproducible. In the theoretical part,
we provide all the relevant proofs, insights and all the important reasoning. We use public datasets
for our experiments and our code contains just public, well-known libraries. The code will be
publicly available after the review process. We do not use seeds for stochastic algorithms, but the
level of variance is not large enough to obtain qualitatively different results. Upon request, we are
willing to provide models trained by us to obtain exactly the same results.

REFERENCES

Motasem Alfarra, Adel Bibi, Philip HS Torr, and Bernard Ghanem. Data dependent randomized
smoothing. arXiv preprint arXiv:2012.04351, 2020.

Cem Anil, James Lucas, and Roger Grosse. Sorting out Lipschitz function approximation. In Kamalika Chaudhuri and Ruslan Salakhutdinov (eds.), Proceedings of the 36th International Confer_ence on Machine Learning, volume 97 of Proceedings of Machine Learning Research, pp. 291â€“_
[301. PMLR, 09â€“15 Jun 2019. URL http://proceedings.mlr.press/v97/anil19a.](http://proceedings.mlr.press/v97/anil19a.html)
[html.](http://proceedings.mlr.press/v97/anil19a.html)

Anish Athalye and Nicholas Carlini. On the robustness of the cvpr 2018 white-box adversarial
example defenses. arXiv preprint arXiv:1804.03286, 2018.

Anish Athalye, Nicholas Carlini, and David Wagner. Obfuscated gradients give a false sense of security: Circumventing defenses to adversarial examples. In International conference on machine
_learning, pp. 274â€“283. PMLR, 2018._

Battista Biggio, Igino Corona, Davide Maiorca, Blaine Nelson, Nedim SrndiÂ´[Ë‡] c, Pavel Laskov, Giorgio Giacinto, and Fabio Roli. Evasion attacks against machine learning at test time. In Hendrik
Blockeel, Kristian Kersting, Siegfried Nijssen, and Filip ZeleznÂ´[Ë‡] y (eds.), Machine Learning and
_Knowledge Discovery in Databases, pp. 387â€“402, Berlin, Heidelberg, 2013. Springer Berlin Hei-_
delberg. ISBN 978-3-642-40994-3.

Nicholas Carlini and David Wagner. Adversarial examples are not easily detected: Bypassing ten detection methods. In Proceedings of the 10th ACM workshop on artificial intelligence and security,
pp. 3â€“14, 2017.

Chen Chen, Kezhi Kong, Peihong Yu, Juan Luque, Tom Goldstein, and Furong Huang. Instars: Instance-wise randomized smoothing for improved robustness and accuracy. arXiv preprint
_arXiv:2103.04436, 2021._

Jeremy Cohen, Elan Rosenfeld, and Zico Kolter. Certified adversarial robustness via randomized
smoothing. In International Conference on Machine Learning, pp. 1310â€“1320. PMLR, 2019.

Francisco Eiras, Motasem Alfarra, M Pawan Kumar, Philip HS Torr, Puneet K Dokania, Bernard
Ghanem, and Adel Bibi. Ancer: Anisotropic certification via sample-wise volume maximization.
_arXiv preprint arXiv:2107.04570, 2021._

Kevin Eykholt, Ivan Evtimov, Earlence Fernandes, Bo Li, Amir Rahmati, Chaowei Xiao, Atul
Prakash, Tadayoshi Kohno, and Dawn Song. Robust physical-world attacks on deep learning
visual classification. In Proceedings of the IEEE conference on computer vision and pattern
_recognition, pp. 1625â€“1634, 2018._

Yue Gao, Harrison Rosenberg, Kassem Fawaz, Somesh Jha, and Justin Hsu. Analyzing accuracy
loss in randomized smoothing defenses. arXiv preprint arXiv:2003.01595, 2020.

Ian J Goodfellow, Jonathon Shlens, and Christian Szegedy. Explaining and harnessing adversarial
examples. arXiv preprint arXiv:1412.6572, 2014.

Ingo GÂ¨uhring, Mones Raslan, and Gitta Kutyniok. Expressivity of deep neural networks. arXiv
_preprint arXiv:2007.04759, 2020._


-----

Jamie Hayes. Extensions and limitations of randomized smoothing for robustness guarantees. In
_Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition Work-_
_shops, pp. 786â€“787, 2020._

Matthias Hein and Maksym Andriushchenko. Formal guarantees on the robustness of a classifier
against adversarial manipulation. In I. Guyon, U. V. Luxburg, S. Bengio, H. Wallach, R. Fergus,
S. Vishwanathan, and R. Garnett (eds.), Advances in Neural Information Processing Systems,
[volume 30. Curran Associates, Inc., 2017. URL https://proceedings.neurips.cc/](https://proceedings.neurips.cc/paper/2017/file/e077e1a544eec4f0307cf5c3c721d944-Paper.pdf)
[paper/2017/file/e077e1a544eec4f0307cf5c3c721d944-Paper.pdf.](https://proceedings.neurips.cc/paper/2017/file/e077e1a544eec4f0307cf5c3c721d944-Paper.pdf)

[Alex Krizhevsky. Learning multiple layers of features from tiny images, 2009. URL http://](http://www.cs.toronto.edu/~kriz/learning-features-2009-TR.pdf)
[www.cs.toronto.edu/Ëœkriz/learning-features-2009-TR.pdf.](http://www.cs.toronto.edu/~kriz/learning-features-2009-TR.pdf)

Aounon Kumar, Alexander Levine, Tom Goldstein, and Soheil Feizi. Curse of dimensionality on
randomized smoothing for certifiable robustness. In International Conference on Machine Learn_ing, pp. 5458â€“5467. PMLR, 2020._

Alexey Kurakin, Ian Goodfellow, and Samy Bengio. Adversarial machine learning at scale. arXiv
_preprint arXiv:1611.01236, 2016._

Yann LeCun, Corinna Cortes, and Christopher J.C. Burges. The mnist database of handwritten
[digits, 1999. URL http://yann.lecun.com/exdb/mnist/.](http://yann.lecun.com/exdb/mnist/)

Mathias Lecuyer, Vaggelis Atlidakis, Roxana Geambasu, Daniel Hsu, and Suman Jana. Certified
robustness to adversarial examples with differential privacy. In 2019 IEEE Symposium on Security
_and Privacy (SP), pp. 656â€“672. IEEE, 2019._

Bai Li, Changyou Chen, Wenlin Wang, and Lawrence Carin. Certified adversarial robustness with
additive noise. Advances in Neural Information Processing Systems, 32:9464â€“9474, 2019.

Aleksander Madry, Aleksandar Makelov, Ludwig Schmidt, Dimitris Tsipras, and Adrian Vladu.
Towards deep learning models resistant to adversarial attacks. arXiv preprint arXiv:1706.06083,
2017.

Matthew Mirman, Timon Gehr, and Martin Vechev. Differentiable abstract interpretation for provably robust neural networks. In Jennifer Dy and Andreas Krause (eds.), Proceedings of the 35th
_International Conference on Machine Learning, volume 80 of Proceedings of Machine Learn-_
_[ing Research, pp. 3578â€“3586. PMLR, 10â€“15 Jul 2018. URL http://proceedings.mlr.](http://proceedings.mlr.press/v80/mirman18b.html)_
[press/v80/mirman18b.html.](http://proceedings.mlr.press/v80/mirman18b.html)

Jeet Mohapatra, Ching-Yun Ko, Sijia Liu, Pin-Yu Chen, Luca Daniel, et al. Rethinking randomized
smoothing for adversarial robustness. arXiv preprint arXiv:2003.01249, 2020a.

Jeet Mohapatra, Ching-Yun Ko, Tsui-Wei Weng, Pin-Yu Chen, Sijia Liu, and Luca Daniel. Higherorder certification for randomized smoothing. Advances in Neural Information Processing Sys_tems, 33, 2020b._

Aditi Raghunathan, Jacob Steinhardt, and Percy Liang. Certified defenses against adversarial examples. In International Conference on Learning Representations, 2018.

Christian Robert. On some accurate bounds for the quantiles of a non-central chi squared distribution. Statistics & probability letters, 10(2):101â€“106, 1990.

Hadi Salman, Jerry Li, Ilya P Razenshteyn, Pengchuan Zhang, Huan Zhang, SÂ´ebastien Bubeck,
and Greg Yang. Provably robust deep learning via adversarially trained smoothed classifiers. In
_NeurIPS, 2019._

Christian Szegedy, Wojciech Zaremba, Ilya Sutskever, Joan Bruna, Dumitru Erhan, Ian Goodfellow,
and Rob Fergus. Intriguing properties of neural networks. arXiv preprint arXiv:1312.6199, 2013.


-----

Yusuke Tsuzuku, Issei Sato, and Masashi Sugiyama. Lipschitz-margin training: Scalable certification of perturbation invariance for deep neural networks. In S. Bengio, H. Wallach, H. Larochelle, K. Grauman, N. Cesa-Bianchi, and R. Garnett
(eds.), Advances in Neural Information Processing Systems, volume 31. Curran Asso[ciates, Inc., 2018. URL https://proceedings.neurips.cc/paper/2018/file/](https://proceedings.neurips.cc/paper/2018/file/485843481a7edacbfce101ecb1e4d2a8-Paper.pdf)
[485843481a7edacbfce101ecb1e4d2a8-Paper.pdf.](https://proceedings.neurips.cc/paper/2018/file/485843481a7edacbfce101ecb1e4d2a8-Paper.pdf)

Tim Van Erven and Peter Harremos. RÂ´enyi divergence and kullback-leibler divergence. _IEEE_
_Transactions on Information Theory, 60(7):3797â€“3820, 2014._

Lei Wang, Runtian Zhai, Di He, Liwei Wang, and Li Jian. Pretrain-to-finetune adversarial training
[via sample-wise randomized smoothing. 2021. URL https://openreview.net/forum?](https://openreview.net/forum?id=Te1aZ2myPIu)
[id=Te1aZ2myPIu.](https://openreview.net/forum?id=Te1aZ2myPIu)

Lily Weng, Huan Zhang, Hongge Chen, Zhao Song, Cho-Jui Hsieh, Luca Daniel, Duane Boning, and
Inderjit Dhillon. Towards fast computation of certified robustness for ReLU networks. In Jennifer
Dy and Andreas Krause (eds.), Proceedings of the 35th International Conference on Machine
_Learning, volume 80 of Proceedings of Machine Learning Research, pp. 5276â€“5285. PMLR,_
[10â€“15 Jul 2018. URL http://proceedings.mlr.press/v80/weng18a.html.](http://proceedings.mlr.press/v80/weng18a.html)

Eric Wong and Zico Kolter. Provable defenses against adversarial examples via the convex outer
adversarial polytope. In International Conference on Machine Learning, pp. 5286â€“5295. PMLR,
2018.

Yihan Wu, Aleksandar Bojchevski, Aleksei Kuvshinov, and Stephan GÂ¨unnemann. Completing the
picture: Randomized smoothing suffers from the curse of dimensionality for a large family of
distributions. In International Conference on Artificial Intelligence and Statistics, pp. 3763â€“3771.
PMLR, 2021.

Greg Yang, Tony Duan, J Edward Hu, Hadi Salman, Ilya Razenshteyn, and Jerry Li. Randomized
smoothing of all shapes and sizes. In International Conference on Machine Learning, pp. 10693â€“
10705. PMLR, 2020.

Runtian Zhai, Chen Dan, Di He, Huan Zhang, Boqing Gong, Pradeep Ravikumar, Cho-Jui Hsieh,
and Liwei Wang. Macer: Attack-free and scalable robust training via maximizing certified radius.
_arXiv preprint arXiv:2001.02378, 2020._

A THE ISSUES OF CONSTANT Ïƒ SMOOTHING

A.1 TOY EXAMPLE

To better demonstrate our ideas, we prepared a two-dimensional simple toy dataset. This dataset
can be seen in Figure 5. The dataset is generated in polar coordinates, having uniform angle and the
distance distributed as a square root of suitable chi-square distribution. The classes are positioned
in a circle sectors, one in a sector with a very sharp angle. The number of training samples is 500
for each class, number of test samples is 100 for each class (except demonstrative figures, where
we increased it to 300). The model that was trained on this dataset was a simple fully connected
three-layer neural network with ReLU activations and a maximal width of 20.

A.2 UNDERCERTIFICATION CAUSED BY THE USE OF LOWER CONFIDENCE BOUNDS

As we mention in Section 1, one can not usually obtain exact values of pA and pB. However, it is
obvious, that for vast majority of evaluated samples, pA < pA and pB > pB. Given the nature of
our certified radius, it follows that R < R, where R denotes the certified radius coming from the
certification procedure with pA and pB, while R here stands for the certified radius corresponding
to true values pA, pB.

It is, therefore, clear, that we face a certain level of under-certification. But how serious undercertification it is? Assume the case with a linear base classifier. Imagine, that we move the point
_x further and further away from the decision boundary. Therefore, pA_ 1. At some point, the
_âˆ’â†’_


-----

probability will be so large, that with high probability, all n samplings in our evaluation of pA will
be classified as A, obtaining Ë†pA = 1 - the empirical probability. The lower confidence bound pA is
therefore bounded by having Ë†pA = 1. Thus, from some point, the certification will yield the same
_pA regardless of the true value of pA. So in practice, we have an upper bound on the certified radius_
_R in the case of the linear boundary. In Figure 7 (left), we see the truncation effect. Using Ïƒ = 1,_
from a distance of roughly 4, we can no longer achieve a better certified radius, despite its theoretical
value equals the distance. Similarly, if we fix a distance of x from decision boundary and vary Ïƒ, for
very small values of Ïƒ, the value of Î¦[âˆ’][1](pA) will no longer increase, but the values of Ïƒ will pull R
towards zero. This behaviour is depicted in Figure 7 (right).

We can also look at it differently - what is the ratio between Î¦[âˆ’][1](pA) and Î¦[âˆ’][1](pA) for different
values of pA? Since R = ÏƒÎ¦[âˆ’][1](pA) and R = ÏƒÎ¦[âˆ’][1](pA), the ratio represents the â€œundercertifi
cation rateâ€. In Figure 6 we plot Î¦Î¦[âˆ’][âˆ’][1][1]((ppAA)) [as a function of][ p][A][ for two different ranges of values.]
The situation is worst for very small and very big values of pA. In the case of very big values, this
can be explained due to extreme nature of Î¦[âˆ’][1]. For small values of pA, it can be explained as a
consequence of a fact, that even small difference between pA and pA will yield big ratio between
Î¦[âˆ’][1](pA) and Î¦[âˆ’][1](pA) due to the fact, that these values are close to 0.

If we look at the left plot on Figure 8 we see, that the certified accuracy plots also possess the
truncations. Above some radius, no sample is certified anymore. The problem is obviously more
serious for small values of Ïƒ. On the right plot of Figure 8, we see, that samples far from the decision
boundary are obviously under-certified. We can also see, that certified radiuses remain constant, even
though in reality they would increase with increasing distance from the decision boundary.

All the observations so far motivate us to use rather large values of Ïƒ in order to avoid the truncation
problem. However, as we will see in the next sections, using a large Ïƒ carries a different, yet equally
serious burden.

A.3 ROBUSTNESS VS. ACCURACY TRADE-OFF

As we demonstrate in the previous subsection, it is be useful to use large values of Ïƒ to prevent the
under-certification. But does it come without a prize? If we have a closer look at Figure 8 (right), we
might notice, that the accuracy on the threshold 0, i.e. â€œclean accuracyâ€, decreases as Ïƒ increases.
This effect has been noticed in the literature (Cohen et al., 2019; Gao et al., 2020; Mohapatra et al.,
2020a) and is called robustness vs. accuracy tradeoff.

There are several reasons, why this problem occurs. Generally, changing Ïƒ changes the decision
boundary of g and we might assume, that due to the high complexity of the boundary of f, the
decision boundary of g becomes smoother. If Ïƒ is too large, however, the decision boundary will be
so smooth, that it might lose some amount of the base classifierâ€™s expressivity. Another reason for the
accuracy drop is also the increase in the number of samples, for which the evaluation is abstained.
This is because using big values of Ïƒ makes more classes â€œwithin the reach of our distributionâ€,
making the pA and pA small. If pA < 0.5 and we do not estimate pB but set pB = 1 âˆ’ _pA, then_

Figure 5: The toy dataset.


-----

Figure 6: The ratio between certified radius if using lower confidence bounds and if using exact
values for the case of linear boundary.

Figure 7: Left: Certified radius as a function of distance in linear boundary case. The truncation
is due to the use of lower confidence bounds. The parameters are n = 100000, Î± = 0.001, Ïƒ = 1.
**Right: Certified radius for a point x at fixed distance 1 from linear boundary as a function of used**
_Ïƒ. The undercertification follows from usage of lower confidence bounds._

Figure 8: Results of certification on toy dataset. Left: Certified accuracy for different levels of Ïƒ.
**Right: Certified radiuses and decision boundary of g visualized directly on test set.**

we are not able to classify the sample as class A, yet we cannot classify it as a different class either,
which forces us to abstain. To demonstrate these results, we computed not only the clean accuracies
of Cohen et al. (2019) evaluations but also the abstention rates. Results are depicted in the Table 4.

From the table, it is obvious, that the abstention rate is possibly even bigger cause of accuracy drop
than the â€œclean misclassificationâ€. This problem can be partially solved if one estimated pB together


-----

|Col1|Accuracy|Abstention rate|Misclassification rate|
|---|---|---|---|
|Ïƒ = 0.12|0.814|0.038|0.148|
|Ïƒ = 0.25|0.748|0.086|0.166|
|Ïƒ = 0.50|0.652|0.166|0.182|
|Ïƒ = 1.00|0.472|0.29|0.238|


Accuracy Abstention rate Misclassification rate

_Ïƒ = 0.12_ 0.814 0.038 0.148

_Ïƒ = 0.25_ 0.748 0.086 0.166

_Ïƒ = 0.50_ 0.652 0.166 0.182

_Ïƒ = 1.00_ 0.472 0.29 0.238

Table 4: Accuracies, rates of abstentions and misclassification rates of Cohen et al. (2019) evaluation
for different levels of Ïƒ.

Figure 9: Heatmaps and decision boudnary of base classifier (top left) and the smoothed classifier
for increasing levels of Ïƒ. As Ïƒ increases, the classifier is more smooth and the decision boundary
recedes.

with pA too. In this way, using big Ïƒ yields generally small estimated class probabilities, but since
of Monte-Carlo samplings for the classification decision, what is almost for free.pA â‰¥ _pB, the problematic pB â‰¥_ _pA occur just very rarely. Another option is to increase the number_

Yet another reason for the decrease in the accuracy is the so-called shrinking phenomenon, which
we will discuss in the next subsection.

In contrast with the truncation effect, the robustness vs. accuracy trade-off motivates the usage of
smaller values of Ïƒ in order to prevent the accuracy loss, which is definitely a very serious issue.

A.4 SHRINKING PHENOMENON

How exactly does the decision boundary of g change, as we change the Ïƒ? For instance, if f is a
linear classifier, then the boundary does not change at all. To answer this question, we employ the
following experiment: For our toy base classifier f on our toy dataset, we increase Ïƒ and plot the
heatmap of f, g, together with its decision boundary. This experiment is depicted on Figure 9. As
we see from the plots, increasing Ïƒ causes several effects. First of all, the heatmap becomes more
and more blurred, what proves, that stronger smoothing implies stronger smoothness.

Second, crucial, effect is that the bigger the Ïƒ, the smaller the decision boundary of a submissive
class is. The shrinkage becomes pronounced from Ïƒ = 1. Already for Ïƒ = 4, there is hardly
any decision boundary anymore. Generally, as Ïƒ âˆ’â†’âˆž, g will predict the class with the biggest
volume in the input space (in the case of bounded input space, like in image domain, this is very
well defined). For extreme values of sigma, the pA will practically just be the ratio between the
volume of A and the actual volume of the input space (for bounded input spaces).


-----

Following from these results, but also from basic intuition, it seems, that an undesired effect becomes
present as Ïƒ increases - the bounded/convex regions become to shrink, like in Figure 9, while the
unbounded/big/anti-convex regions expand. This is called shrinking phenomenon. Mohapatra et al.
(2020a) investigate this effect rather closely. They define the shrinkage and vanishing of regions
formally and prove rigorously, that if Ïƒ âˆ’â†’âˆž, bounded regions, or semi-bounded regions (see
Mohapatra et al. (2020a)) will eventually vanish. We formulate the main result in this direction.

**Theorem 9. Let us have K the number of classes and the dimension N** . Assume, that we have some
bounded decision region D for a specific class roughly centered around 0. Further assume, that this
is the only region where the class is classified. Let R be a smallest radius such that _BR(0)._
Then, this decision region will vanish at most for Ïƒ â‰¥ _[R]âˆšâˆšNK_ [.] _D âŠ‚_

_Proof. The idea of the proof is not very hard. First, the authors prove, that the smoothed region will_
be a subset of the smoothed BR(0). Then, they upper-bound the vanishing threshold of such a ball
in two steps. First, they show, that if 0 is not classified as the class, then no other point will be (this
is quite an intuitive geometrical statement. The BR(0) has the biggest probability under (x, Ïƒ[2]I)
_N_
if x 0). Second, they upper-bound the threshold for Ïƒ, under which BR(0) will have probability
_â‰¡_
below _K[1]_ [(since they use slightly different setting as Cohen et al. (2019)) for the][ N] [(][x, Ïƒ][2][I][)][. Using]

some insights about incomplete gamma function, which is known to be also the cdf of central chisquare distribution, and some other integration tricks, they obtain the resulting bound.

Besides Theorem 9, authors also claim many other statements abound shrinking, including shrinking
of semi-bounded regions. Moreover, they also conduct experiments on CIFAR10 and ImageNet to
support their theoretical findings. They also point out serious fairness issue that comes out as a
consequence of the shrinkage phenomenon. For increasing levels of Ïƒ, they measure the class-wise
clean accuracy of the smoothed classifier. If f is trained with gaussian data augmentation (what is
known to be a good practice in randomized smoothing), using Ïƒ = 0.12, the worst class cat has test
accuracy of 67%, while the best class automobile attains the accuracy of 92%. The figures, however,
change drastically, if we use Ïƒ = 1 instead. In this case, the worst predicted class cat has accuracy
of poor 22%, while ship has reasonable accuracy 68%. As authors claim, this is a consequence of
the fact that samples of cat are situated more in bounded, convex regions, that suffer from shrinking,
while samples of ship are mostly placed in expanded regions of anti-convex shape that will expand
as the Ïƒ grows. In addition, the authors also show, that the gaussian data augmentation or adversarial
training will reduce the shrinking phenomenon just partially and for moderate and high values of Ïƒ,
this effect will be present anyway.

We must emphasize, that this is a serious fairness issue, that has to be treated before randomized
smoothing can be fully used in practice. For instance, if we trained a neural network to classify
humans into several categories, fairness of classification is inevitable and the neural network cannot
be used until this issue is solved.

Similarly as the robustness vs. accuracy tradeoff, this issue also motivates to use rather smaller
values of Ïƒ. We see, that it is not possible to address all three problems consistently because they
disagree on whether to use smaller, or bigger values of Ïƒ .

A.5 EXPERIMENTS ON HIGH-DIMENSIONAL TOY DATASET

In this subsection, we present the results of our motivational experiment on a synthetic dataset.
Before reading this section, please read our main text, because we will use the necessary notation of
the paper.

The dataset we evaluated our method on is a generalization of the dataset visualized on Figure 1.
The data points from one class lie in a cone of small angle and the points are generated such that
the density is higher near the vertex of the cone (which is put in origin). Points from other class
are generated from a spherically symmetrical distribution (where points sampled into the cone are
excluded) with density again highest in the center (note, that the density peak is more pronounced
than in the case of normal distribution, where the density around the center resembles uniform distribution). This dataset is chosen so that the Ïƒ(x) function designed in Equation 1 well corresponds
to the geometry of the decision boundary. Moreover it is chosen so that the conic decision region


-----

|Dimension|Ïƒ (Ïƒ ) b|r|Accuracy|
|---|---|---|---|
|2|0.5|-|0.943|
|2|0.4|0.2|0.96|
|2|0.5|0.2|0.943|
|6|0.5|-|0.946|
|6|0.4|0.1|0.963|
|18|1.0|-|0.86|
|18|0.8|0.05|0.886|
|60|1.0|-|0.83|
|60|0.8|0.03|0.85|
|60|1.0|0.03|0.83|
|180|2.0|-|0.713|
|180|1.9|0.01|0.726|
|400|2.0|-|0.623|
|400|1.95|0.005|0.623|


Dimension _Ïƒ (Ïƒb)_ _r_ Accuracy

2 0.5 - 0.943

2 0.4 0.2 0.96

2 0.5 0.2 0.943

6 0.5 - 0.946

6 0.4 0.1 0.963

18 1.0 - 0.86

18 0.8 0.05 0.886

60 1.0 - 0.83

60 0.8 0.03 0.85

60 1.0 0.03 0.83

180 2.0 - 0.713

180 1.9 0.01 0.726

400 2.0 - 0.623

400 1.95 0.005 0.623

Table 5: Clean accuracies of different evaluations of our toy experiment.

will shrink rather fast with increasing Ïƒ. The motivation of this example is to show that if the Ïƒ(x)
function is well-designed, our IDRS can outperform the constant RS considerably.

The setup of our experiment is as follows: We evaluate dimensions N = 2, 6, 18, 60, 180, 400.
The Ïƒ used for constant smoothing is Ïƒ = 0.5, 0.5, 1.0, 1.0, 2.0, 2.0 respectively. The Ïƒb used is
0.4, 0.5 for N = 2, 0.4 for N = 6, 0.8 for N = 18, 0.8, 1.0 for N = 60, 1.9 for N = 180 and
1.95 for N = 400. The rates are r = 0.2, 0.1, 0.05, 0.03, 0.01, 0.005 respectively. The training
was executed without data augmentation (because samples from different classes are very close to
each other). Moreover, we have set maximal Ïƒ(x) threshold for numerical purposes, because some
samples were outliers and were way too far from other samples (and if the Ïƒ(x) is way too big, the
method encounteres numerical problems). In this case we set Ïƒ(x) 5Ïƒb, but we are aware that
_â‰¤_
also much bigger thresholds would have been possible. We present our comparisons in Figure 10
and Table 5.

From both the Figure 10 an Table 5 it is clear that the IDRS can outperform the constant Ïƒ RS considerably, if we use really suitable Ïƒ(x) function. We manage to improve significantly the certified
radiuses without losing a single correct classification. On the other hand, in cases where Ïƒb < Ïƒ,
we outperform constant Ïƒ both in clean accuracy and in certified radiuses. This example is synthetic
and designed in our favour. The main message is not how perfect our design of Ïƒ(x) is, but the fact,
that if Ïƒ(x) is designed well, the IDRS can bring real advantages, even in moderate dimensions.

B MORE ON THEORY

B.1 GENERALIZATION OF RESULTS FROM LI ET AL. (2019)

In our main text, we mostly focus on the generalization of the methods from Cohen et al. (2019).
This is because these methods yield tight radiuses and because the application of Neyman-Pearson
lemma is beautiful. However, the methodology from Li et al. (2019) can also be generalized for
the input-dependent RS. To be able to do it, we need some auxiliary statements about the RÂ´enyi
divergence.

**Lemma 10. The RÂ´enyi divergence between two one-dimensional normal distributions is as follows:**


_DÎ±(_ (Âµ1, Ïƒ1[2][)][||N] [(][Âµ][0][, Ïƒ]0[2][)) =][ Î±][(][Âµ][1][ âˆ’] _[Âµ][2][)][2]_
_N_ 2ÏƒÎ±[2]

provided, that ÏƒÎ±[2] [:= (1][ âˆ’] _[Î±][)][Ïƒ]1[2]_ [+][ Î±Ïƒ]0[2] _[â‰¥]_ [0][.]

_Proof. See Van Erven & Harremos (2014)._


1 _ÏƒÎ±_

1 _Î±_ [log] _Ïƒ1[1][âˆ’][Î±]Ïƒ0[Î±]_
_âˆ’_ 


-----

Figure 10: Certified accuracy plots of our multidimensional toy experiments.

Note, that this proposition induces some assumptions on how Ïƒ0, Ïƒ1, Î± should be related. If Ïƒ0 > Ïƒ1,
then the required inequality holds for any 1 Ì¸= Î± > 0. If Ïƒ0 < Ïƒ1, then Î± is restricted and we need
to keep that in mind.

**Lemma 11.** Assume, we have some one-dimensional distributions P1, P1, . . ., PN and
_Q1, Q2, . . ., QN defined on common space for pairs with the same index. Then, assuming product_
space with product Ïƒ-algebra, we have the following identity:


_DÎ±(_ 1 2 _N_ 1 2 _N_ ) =
_P_ _Ã— P_ _Ã— Â· Â· Â· Ã— P_ _||Q_ _Ã— Q_ _Ã— Â· Â· Â· Ã— Q_


_DÎ±(_ _i_ _i)._
_P_ _||Q_
_i=1_

X


-----

_Proof. See Van Erven & Harremos (2014)._

Using these two propositions, we are now able to derive a formula for RÂ´enyi divergence between
two multivariate isotropic normal distributions:

**Lemma 12.**


_Î±_ _Ïƒ0_

1 _Î±_ [log] _Ïƒ1_
_âˆ’_ 


_Î±_ _x0_ _x1_ log _ÏƒÏƒÎ±1_
_DÎ±(_ (x1, Ïƒ1[2][I][)][||N] [(][x][0][, Ïƒ]0[2][I][)) =] _âˆ¥_ _âˆ’_ _âˆ¥[2]_ _N_
_N_ 2Ïƒ1[2] [+ 2][Î±][(][Ïƒ]0[2] _[âˆ’]_ _[Ïƒ]1[1][) +][ N]_ 1 âˆ’ _Î±_  _âˆ’_


_Proof. Imporant property that is needed here is, that isotropic gaussian distributions factorize to_
one-dimensinal independent marignals. In other words:

_N_ (x1, Ïƒ1[2][I][) =][ N] [(][x][11][, Ïƒ]1[2][)][ Ã— N] [(][x][12][, Ïƒ]1[2][)][ Ã— Â· Â· Â· Ã— N] [(][x][1][N] _[, Ïƒ]1[2][)][,]_

and analogically for x0. Therefore, using Lemma 11 we see:


_DÎ±(N_ (x1, Ïƒ1[2][I][)][||N] [(][x][0][, Ïƒ]0[2][I][)) =]


_DÎ±(N_ (x1i, Ïƒ1[2][)][||N] [(][x][0][i][, Ïƒ]0[2][))][.]
_i=1_

X


Now, it suffices to plug in the formula from Proposition 10 to obtain the required result:


1 _ÏƒÎ±_

_DÎ±(_ (x1i, Ïƒ1[2][I][)][||N] [(][x][0][i][, Ïƒ]0[2][I][)) =][ Î±][(][x][1][i][ âˆ’] _[x][2][i][)][2]_ +
_N_ 2ÏƒÎ±[2] 1 _Î±_ [log] _Ïƒ1[1][âˆ’][Î±]Ïƒ0[Î±]_

_âˆ’_  

_Î±(x1i_ _x2i)[2]_ log _ÏƒÏƒÎ±1_ _Î±_ _Ïƒ0_
= _âˆ’_

2Ïƒ1[2] [+ 2][Î±][(][Ïƒ]0[2] 1[) +] 1  _Î±_  _âˆ’_ 1 _Î±_ [log] _Ïƒ1_

_[âˆ’]_ _[Ïƒ][1]_ _âˆ’_ _âˆ’_ 

Now it suffices to sum up over i and the result follows.


To obtain the certified radius, we also need a result from Li et al. (2019), which gives a guarantee
that two measures on the set of classes will share the modus if the Rnyi divergence between them is
small enough.

LetLemma 13. pA, pB correspond to two biggest probabilities in distribution Let P = (p1, p2, . . ., pK) and Q = (q1, q2, . . ., qK P) two discrete measures on. Let M1(a, b) = _a+2_ _b_ and C.

1

_M1âˆ’Î±(a, b) = (_ _[a][1][âˆ’][Î±][+]2_ _[b][1][âˆ’][Î±]_ ) 1âˆ’Î± If

_DÎ±(Q_ P) log(1 2M1(pA, pB) + 2M1 _Î±(pA, pB)),_
_||_ _â‰¤âˆ’_ _âˆ’_ _âˆ’_

then the distributions P and Q agree on the class with maximal assigned probability.

_Proof. This lemma can be proved by directly computing the minimal required DÎ± to be able to_
disagree on the maximal class probabilities via a constrained optimization problem (with variables
_pi, qi, i_ 1, . . ., K ), solving KKT conditions. For details, consult Li et al. (2019).
_âˆˆ{_ _}_

Having explicit formula for the Rnyi divergence, we can mimic the methodology of Li et al. (2019)
to obtain the certified radius:

**Theorem 14. Given x0, pA, pB, Ïƒ0, N**, the certified radius squared for all x1 such that fixed Ïƒ1 is
used is:


_Î±_ _Ïƒ0_

1 _Î±_ [log] _Ïƒ1_
_âˆ’_ 


_N_ log _ÏƒÏƒÎ±1_
_âˆ’_ 1  _Î±_

_âˆ’_


2Ïƒ1[2] [+ 2][Î±][(][Ïƒ]0[2] _[âˆ’]_ _[Ïƒ]1[1][)]_

_Î±_


_R[2]_ = sup
_Î±âˆˆSÏƒ0_ _,Ïƒ1_


_âˆ’_ log(1 âˆ’ 2M1(pA, pB) + 2M1âˆ’Î±(pA, pB))


where SÏƒ0,Ïƒ1 = R+, if Ïƒ0 > Ïƒ1 and SÏƒ0,Ïƒ1 = 0, _Ïƒ1[2]Ïƒ[âˆ’]1[2][Ïƒ]0[2]_



if Ïƒ0 < Ïƒ1.


-----

_Proof. Let us fix x1 and assume, that Î± âˆˆ_ _SÏƒ0,Ïƒ1_ . Then, due to post-processing inequality for Renyi
divergence, it follows that

_DÎ±(f_ (x1 + N (0, Ïƒ1[2][I][))][||][f] [(][x][0] [+][ N] [(0][, Ïƒ]0[2][I][)))][ â‰¤] _[D][Î±][(][x][1]_ [+][ N] [(0][, Ïƒ]1[2][I][)][||][x][0] [+][ N] [(0][, Ïƒ]0[2][I][))]

_Î±_ _x0_ _x1_ log _ÏƒÏƒÎ±1_ _Î±_ _Ïƒ0_
= _âˆ¥_ _âˆ’_ _âˆ¥[2]_ _N_ _._

2Ïƒ1[2] [+ 2][Î±][(][Ïƒ]0[2] 1[) +][ N] 1  _Î±_  _âˆ’_ 1 _Î±_ [log] _Ïƒ1_

_[âˆ’]_ _[Ïƒ][1]_ _âˆ’_ _âˆ’_  

Due to Lemma 13, it suffices that the following inequality holds for some Î± _SÏƒ0,Ïƒ1_ :
_âˆˆ_

_Î±_ _x0_ _x1_ log _ÏƒÏƒÎ±1_ _Î±_ _Ïƒ0_
_âˆ¥_ _âˆ’_ _âˆ¥[2]_ _N_

2Ïƒ1[2] [+ 2][Î±][(][Ïƒ]0[2] 1[) +][ N] 1  _Î±_  _âˆ’_ 1 _Î±_ [log] _Ïƒ1_ _â‰¤_

_[âˆ’]_ _[Ïƒ][1]_ _âˆ’_ _âˆ’_  

_âˆ’_ log(1 âˆ’ 2M1(pA, pB) + 2M1âˆ’Î±(pA, pB)).

This can be rewritten w.r.t. _x0_ _x1_ :
_âˆ¥_ _âˆ’_ _âˆ¥[2]_

1 [+ 2][Î±][(][Ïƒ]0[2] 1[)] _Î±_ _Ïƒ0_ log _ÏƒÏƒÎ±1_
_âˆ¥x0 âˆ’_ _x1âˆ¥[2]_ _â‰¥_ [2][Ïƒ][2] _Î±_ _[âˆ’]_ _[Ïƒ][1]_ _N_ 1 _Î±_ [log] _Ïƒ1_ _âˆ’_ _N_ 1  _Î±_ 

_âˆ’_   _âˆ’_


_âˆ’_ log(1 âˆ’ 2M1(pA, pB) + 2M1âˆ’Î±(pA, pB))!.

The resulting certified radius squared is now simply obtained by taking maximum over _x0_ _x1_
s.t. âˆƒÎ± âˆˆ _SÏƒ0,Ïƒ1 such that the preceding inequality holds._ _âˆ¥_ _âˆ’_ _âˆ¥[2]_

Note, that this theorem is formulated assuming, that except in x0, we use Ïƒ1 everywhere. It would
require some further work to generalize this for general Ïƒ(x) functions, but to demonstrate the next
point, it is not even necessary. Looking at the expression, we can observe that

_Î±_ _Ïƒ0_ log _ÏƒÏƒÎ±1_
_N_ _N_

1 _Î±_ [log] _Ïƒ1_ _âˆ’_ 1  _Î±_ 
_âˆ’_   _âˆ’_

depends highly on N and even for a ratio of _Ïƒ[Ïƒ]1[0]_ [close to 1, we already obtain very strong negative]

values for high dimensions. The expression log(1 âˆ’ 2M1(pA, pB) + 2M1âˆ’Î±(pA, pB)) is far less
sensitive w.r.t pA and for large dimensions of N it is easily â€œbeatenâ€ by the first expression. Therefore, the higher the dimension N is, the bigger pA or the closer to 1 the _[Ïƒ]Ïƒ[0]1_ [has to be in order to]

obtain even valid certified radius (not to speak about big). This points out that also the method of Li
et al. (2019) suffers from the curse of dimensionality, as we know it must have done. This method
is not useful for big N, because the conditions on pA, Ïƒ0, Ïƒ1 are so extreme, that barely any inputs
would yield a positive certified radius. This fact is depicted in the Figure 11.

The key reason why this happens if done via RÂ´enyi divergences is that while the divergence
_DÎ±(_ (x1, Ïƒ1[2][I][)][||N] [(][x][0][, Ïƒ]0[2][I][))][ grows independently of dimension as][ âˆ¥][x][0]
increases for bigdimensions we have, the more dissimilar areN _N even if x1 = x0! This reflects the effect, that if N_ (x1, Ïƒ1[2][I][)][ and][ N] [(][x][0][, Ïƒ]0[2][I] Ïƒ[âˆ’][))]0[. We can think of it as a][x] Ì¸[1]=[âˆ¥] _Ïƒ[grows, it drastically]1, then the more_
consequence of standard fact from statistics that the more data we have, the more confident statistics
against the null hypothesis Ïƒ0 = Ïƒ1 will we get if the null hypothesis is false. Since isotropic normal
distributions can be actually treated as a sample of one-dimensional normal distributions, this is in
accordance with our multivariate distributions setting.

B.2 THE EXPLANATION OF THE CURSE OF DIMENSIONALITY

In the Section 2 we show that input-dependent RS suffers from the curse of dimenisonality. Now we
will elaborate a bit more on this phenomenon and try to explain why it occurs. First, it is obvious
from the Subsection B.1, that also the generalized method of Li et al. (2019) suffers from the curse
of dimensionality, because the RÂ´enyi divergence between two isotropic Gaussians with different
variances grows considerably with respect to dimension. This suggests that the input-dependent RS
might suffer from the curse of dimensionality in general. To motivate this idea even further, we
present this easy observation:


-----

Figure 11: The certified radius as a function of dimension. Paremeters are pA = 0.99, Ïƒ0 = 1, Ïƒ1 =
0.8

**Theorem 15. Denote RC to be a certified radius given for pA and Ïƒ0 at x0 assuming the constant**
_Ïƒ0 and following the certification of Cohen et al. (2019)_ [1]. Assume, that we do the certification for
each x1 by assuming the worst case-classifier as in Theorem 2. Then, for any x0, any function Ïƒ(x)
and any pA, the following inequality holds:

_R_ _RC_
_â‰¤_

_Proof. Fix x1 and Ïƒ1. From Theorem 2 we know that the worst-case classifier f_ _[âˆ—]_ defines a ball B
such that P0(B) = 1 âˆ’ _pA. From this it obviously follows, that the linear classifier fl and the linear_
space Bl that assume constant Ïƒ0 also for x1 and is the worst-case for Ïƒ0 such that P0(Bl) = 1 _âˆ’_ _pA_
is not worst-case for the case of using Ïƒ1 instead. Therefore, P1(Bl) â‰¤ P1(B).

Moreover, let P[C]1 [be a probability measure corresponding to][ N] [(][x][1][, Ïƒ][0][I][)][, i.e. the probability mea-]
sure assuming constant Ïƒ0. It is easy to see that P[C]1 [(][B][l][)][ >][ 0][.][5][ â‡]â‡’ P1(Bl) > 0.5 because the
probability of a linear half-space under isotropic normal distribution is bigger than half if and only
if the mean is contained in the half-space.

Assume, for contradiction that R > RC. From that, it exists a particular x1 such that P[C]1 [(][B][l][)][ >]
0.5 > P1(B), because otherwise there would be no such point, which would cause R > RC.
However, P[C]1 [(][B][l][)][ >][ 0][.][5 =]â‡’ P1(Bl) > 0.5, thus P1(Bl) > P1(B) and that is contradiction.

This theorem shows, that we can never achieve a better certified radius at x0 using Ïƒ0 and having
probability pA than that, which we would get by Cohen et al. (2019)â€™s certification. Of course, this
does not mean, that using non-constant Ïƒ is useless, since Ïƒ0 can vary. The question is, how much
do we lose using non-constant Ïƒ. To get a better intuition, we plot the functions Î¾< and Î¾> under
different setups in Figure 12, together with P1(Bl) from the proof of Theorem 15. From the top row
we can deduce that dimension N has a very significant impact on the probabilities and therefore also
on the certified radius. We particularly point out the fact, that even Î¾>(0), Î¾<(0) can have significant
margin w.r.t. to the probability coming out of linear classifier.[2] Already for N = 90, we are not able
to certifyÏƒ0 _pA = 0.99 for rather conservative value of_ _[Ïƒ]Ïƒ[0]1_ [. From middle row we see, that decreasing]

_Ïƒ1_ [can mitigate this effect strongly. For instance, for][ Ïƒ][0][ = 1][, Ïƒ][1][ = 0][.][95][ the difference between]
P1(B) and P1(Bl) is almost negotiated. Bottom row compares Î¾>(a), Î¾<(a) and the respective
linear classifier probabilities. We can see, that the case Ïƒ0 < Ïƒ1 might cause stronger restrictions on
our certification (yet we deduce it just form the picture).

1The â€œCâ€ in the subscript of certified radius might come both from â€œconstantâ€ and â€œCohen et. al.â€
and then grows rather reasonably with distance.2Notice the similarity with RÂ´enyi divergence, which also has positive value even for x0 = x1 if Ïƒ0 Ì¸= Ïƒ1


-----

Figure 12: Plots of Î¾>(a), Î¾<(a) for different setups. Coding for parameters is: [Ïƒ0, Ïƒ1, N, pB] Top:
_Î¾>(a) left, Î¾<(a) right, varying values of N_ . Center: On the left, Î¾>(a) for varying Ïƒ1, on the right
_Î¾>(a) for varying pB. Bottom: Î¾>(a) and Î¾<(a) compared._

What is the reason for Î¾>(a), Î¾<(a) being so big even at 0? The problem is following: Assume
_Ïƒ0 > Ïƒ1. If x0 = x1, the worst-case classifier coming from Lemma 2 will be a ball B centered right_
at x0, such that P0(B) = 1 âˆ’ _pA. If we look at P1(B), we see, that we have the same ball centered_
directly at the mean, but the variance of the distribution is smaller. Using spherical symmetry of the
isotropic gaussian distribution, this is equivalent to evaluating the probability of a bigger ball. If we
fix _[Ïƒ]Ïƒ[0]1_ [and look at the ratio of probabilities][ P]P[1]0[(]([B]B[)]) [with increasing][ N] [, the curse of dimensionality]

comes into the game. For N = 2, the ratio is not too big. However, if N = 3072, like in CIFAR10,
this ratio is far bigger. This can be intuitively seen from a property of chi-square distribution (which
is present in the case x0 = x1), that while expectation is N, the standard deviation is â€œjustâ€ _âˆš2N_,

_âˆšV ar(Ï‡[2]N_ [)]
i.e. E(Ï‡[2]N [)] _âˆ’â†’_ 0 as N âˆ’â†’âˆž.

B.3 WHY DOES THE INPUT-DEPENDENT SMOOTHING WORK BETTER FOR SMALL Ïƒ VALUES?

As can be observed in Section 4 and Appendix E, the bigger the Ïƒb = Ïƒ we use, the harder it is to
keep up to standards of constant smoothing. An interesting question is, why is the usage of small
_Ïƒb = Ïƒ helpful for the input-dependent smoothing?_

Assume fixed Ïƒ, say Ïƒb = Ïƒ = 0.12. The theoretical bound on the certified radius given 100000
Monte-Carlo samplings and 0.001 confidence level using constant smoothing is about 0.48. Having


-----

Figure 13: Comparison of certified radius as a function of distance for constant and input-dependent
smoothing. Left: Ïƒb = Ïƒ = 0.12, right: Ïƒb = Ïƒ = 0.50.

_Ïƒ(x) âˆ¼_ 0.12, we cannot expect much bigger certified radius. Therefore, if we follow Theorem 7,
the values of exp(âˆ’rR) and exp(rR) in the critical distance âˆ¼ 0.5 will be much closer to 1, than
the values of exp(âˆ’rR) and exp(rR) if we used Ïƒb = Ïƒ = 0.50 instead, where the critical values
of R could be much bigger than 0.5. Therefore, the â€œgainâ€ in P1(B) imposed by the curse of
dimensionality, compared to P1(B) assuming constant Ïƒ will not be that severe yet. This means,
that the loss in certified radius caused by the curse of dimensionality will be much less pronounced
on the â€œactiveâ€ range of certified radiuses (those for which the constant smoothing still works),
compared to using big Ïƒb = Ïƒ. To support this idea, we demonstrate it on Figure 13, where we
depict the certified radius as a function of distance from decision boundary, assuming f to be a
linear classifier, using Ïƒb = Ïƒ = 0.12 and Ïƒb = Ïƒ = 0.50 for comparison.

B.4 HOW DOES THE CURSE OF DIMENSIONALITY AFFECT THE TOTAL POSSIBLE
VARIABILITY OF Ïƒ(x)?

Fix certain type of task, say RGB image classification with images of similar object, but consider
many possible resolutions (dimensions N ). Given two random images from the test set (x0, x1),
what is the biggest reasonable value of _Ïƒ(x0)/Ïƒ(x1)_ 1 ? Theoretically, the expression is bounded
_|_ _âˆ’_ _|_
by exp( _r_ _x0_ _x1_ ) 1, given that r is the semi-elasticity constant of Ïƒ(x). However, the
average distance between two samples from a test set of constant size, but increasing dimension | _Â±_ _âˆ¥_ _âˆ’_ _âˆ¥_ _âˆ’_ _|_
scales as _âˆšN_ . Therefore, with constant r, this upper-bound increases.

The increasing distance between samples is, therefore, a countereffect to the curse of dimensionality.
asIn simple words, we have â€œmore distance to change 1/âˆšN, the increasing distances would cancel the effect of the curse of dimensionaity and as a Ïƒ(x0) to Ïƒ(x1)â€. Even if the r decreased just

result, the maximal reasonable value of _Ïƒ(x0)/Ïƒ(x1)_ 1 would remain roughly constant w.r.t. N .
_|_ _âˆ’_ _|_
However, we need to take into account another effect. As the dimension increases, also the average
distance of samples from the decision boundary increases. This is because the distances in general
grow with dimension and if we assume that the number of intersections of a line segment between
_x0 and x1 with the decision boundary of the network remains roughly constant then the average_
distance from the decision boundary grows as _âˆšN too. In order to compensate for this, we need to_

adjust the basic level of Ïƒ(x) (which we later call Ïƒb and can be understood as the general offset of
our Ïƒ(x)) as _âˆšN too. This is because the maximal attainable certified radius given fixed confidence_

level Î± and the number of Monte-Carlo samples is a constant multiple of Ïƒ(x).

However, with increased Ïƒ, we need to decrease the semi-elasticity rate r in order to obtain full
certifications (see also Appendix B.3 for intuition behind this).

As a sketch of proof, we provide a simple computation, which tells us the approximate asymptotic
behavior of _Ïƒ(x0)/Ïƒ(x1)_ 1 . By Theorem 5 it holds:
_|_ _âˆ’_ _|_


log(pB)
_âˆ’_


exp(âˆ’rc


_N_ ) â‰¥


1 âˆ’ 2


-----

if we want to be able to predict a certified radius of câˆšN (though this is just a necessary condition.

For sufficiency, the LHS must be much closer to 1). After simple manipulation, we obtain:


log(pB)
_âˆ’_


log(pB)
_âˆ’_


log(pB)
_âˆ’_

_cN_


_r â‰¤âˆ’_


log


1 âˆ’ 2


_âˆ¼âˆ’_


(âˆ’1)2


2c


2c


So the rate scales as 1/N . Now we have:

_Ïƒ(x0)/Ïƒ(x1)_ 1 exp( _r_ _x0_ _x1_ ) 1 exp(r _x0_ _x1_ ) 1
_|_ _âˆ’_ _| â‰¤|_ _Â±_ _âˆ¥_ _âˆ’_ _âˆ¥_ _âˆ’_ _| â‰¤_ _âˆ¥_ _âˆ’_ _âˆ¥_ _âˆ’_ _â‰¤_

log(pB) _C log(pB)_

exp( _âˆ’_ _CâˆšN_ ) 1 _âˆ’_ _._

_cN_ _âˆ’_ _âˆ¼_ _câˆšN_

p p


B.5 DOES THE CURSE OF DIMENSIONALITY APPLY IN MULTI-CLASS REGIME?

In the main text, we presented a setup, where pB is set to be 1 _âˆ’_ _pA. This is equivalent to pretending_
that we have just 2 classes. By not estimating the proper value of pB we lose some amount of
power and the resulting certified radius is smaller than it could have been, did we have the pB as
well. This is most pronounced for datasets with many classes. The natural question, therefore, is,
whether we could avoid the curse of dimensionality by properly estimating the pB together with pA.
The answer is no. The problem is that the the theory in Section 2 already implicitly works with the
estimate of pB in a form of 1 âˆ’ _pA. The theory would work also with any other estimate of pB._
Assuming constant pB, instead of constant pA, as we did in Section 2, will, therefore, yield the same
conclusions. Moreover, there is neither theoretical, nor practical reason, why should pB decrease
with increasing dimension.

This insight even applies to the question of the usage of input-dependent RS in practice. The assumption pB = 1 _âˆ’_ _pA is no more important in Section 3 than in Section 2. Therefore, we can apply_
our method also for the pB obtained directly by Monte-Carlo sampling for the class B (or by any
other estimation method).

C CONCURRENT WORK

As we mention in Section 1, the idea to use input-dependent RS is not new. It has popped out in
years 2020 and 2021 in at least four works from three completely distinct groups of authors, even
though none of these works has been successfully published yet. We find it necessary to comment
on all of these works because of two orthogonal reasons. First, it is a good practice to compare our
work with the concurrent work to see what are pros and cons of these similar approaches and to what
extend the approaches differ. Second, we are convinced, that three of these four works claim results,
which are not mathematically valid. We find this to be a particularly critical problem in a domain
such as certifiable robustness, which is by definition based on rigorous, mathematical certifications.

C.1 THE WORK OF WANG ET AL. (2021)

This work, submitted for the ICLR conference 2021 is the only work that seems to be mathematically
functional. In this work, authors have two main contributions â€“ first, they propose a two-phase
training, where in the second phase, for each sample xi, roughly the optimal Ïƒi is being found and
then this sample xi is being augmented with this Ïƒi as an augmentation standard deviation. Authors
call this method pretrain to finetune. Second, they provide a specific version of input-dependent
RS. Essentially, they try to overcome the mathematical problems connected to the usage of nonconstant Ïƒ(x) by splitting the input space in so called robust regions Ri, where the constant Ïƒi is
guaranteed to be used. All the certified balls are guaranteed to lie within just one of these robust
regions, making sure that within one certified region, constant level of Ïƒ is used. Authors test this
method on CIFAR10 and MNIST and show, that the method can outperform existing state-of-the-art
approaches, mainly on the more complex CIFAR10 dataset.

However, we make several points, which make the results of this work, as well as the proposed
method less impressive:


-----

_â€¢ The computational complexity of both their train-time and test-time algorithms seems to_
be quite high.

_â€¢ The final smoothed classifier depends on the order of the incoming samples. As a conse-_
quence, it is not clear, whether the method works well for any permutation of the wouldbe tested samples. This creates another adversarial attack possibility - to attack the final
smoothed classifier by manipulating the test set so that the order of samples is inappropriate
for the good functionality of the final smoothed classifier.

_â€¢ Even more, the fact, that the smoothed classifier depends on the order of the would-be_
tested samples makes it necessary, that the same smoothed classifier is used all the time
for some test session in a real-world applications. For instance, a camera recognizing faces
to approve an entry to a high-security building would need to keep the same model for its
whole functional life, because restarting the model would enable attackers to create attacks
on the predictions from the previous session. This might lead to significant restrictions on
the practical usability of this method.

C.2 THE WORKS OF ALFARRA ET AL. (2020) AND EIRAS ET AL. (2021)

In these works, similarly as in the work of Chen et al. (2021), authors suggest to optimize in each
test point x for such a Ïƒ(x), that maximizes the certified radius given by Zhai et al. (2020), which is
an extension of Cohen et al. (2019)â€™s certified radius for soft smoothing. The optimization for Ïƒ(x)
differs but is similar in some respect (as will be discussed).

Besides, all three works further propose input-dependent training procedure, for which Ïƒ(x) - the
standard deviation of gaussian data augmentation is also optimized. Altogether, both authors claim
strong improvements over all the previous impactful works like Cohen et al. (2019); Zhai et al.
(2020); Salman et al. (2019). The only significant difference between the works of Alfarra et al.
(2020) and Eiras et al. (2021) (which have strong author intersections) is that in Eiras et al. (2021),
authors build upon Alfarra et al. (2020)â€™s work and move from the isotropic smoothing to the
smoothing with some specific anisotropic distributions.

As mentioned, authors first deviate from the setup of Cohen et al. (2019) and turn to the setup
introduced by Zhai et al. (2020), i.e. they use soft smoothed classifier G defined as

_GF (x)C = EÎ´âˆ¼N (0,Ïƒ2I)F_ (x + Î´)C.

The key property of soft smoothed classifiers is that the Cohen et al. (2019)â€™s result on certified
radius holds for them too.

**Theorem 16 (certified radius for soft smoothed classifiers). Let G be the soft smoothed probability**
predictor. Let x be s.t.
_G(x)A_ _EA_ _EB_ _G(x)B._
_â‰¥_ _â‰¥_ _â‰¥_

Then, the smoothed classifier g is robust at x with radius

_R =_ _[Ïƒ]2 [(Î¦][âˆ’][1][(][E][A][)][ âˆ’]_ [Î¦][âˆ’][1][(][E][B][)) =][ Ïƒ][ Î¦][âˆ’][1][(][E][A][) + Î¦]2[âˆ’][1][(1][ âˆ’] _[E][B][))]_ _,_

where Î¦[âˆ’][1] denotes the quantile function of standard normal distribution.

_Proof. Is provided in Zhai et al. (2020)._

Note, that it is, similarly as in the hard randomized smoothing version of this theorem, essential to
provide lower and upper confidence bounds for G(x)A and G(x)B, otherwise we cannot use this
theorem with the required probability that the certified radius is valid. Denote G(x, Ïƒ) to be the soft
smoothed classifier using Ïƒ in x. Authors propose to use the following theoretical Ïƒ(x) function:


_Ïƒ_

2 [(Î¦][âˆ’][1][(][G][(][x, Ïƒ][(][x][))][A][)][ âˆ’] [Î¦][âˆ’][1][(][G][(][x, Ïƒ][(][x][))][B][))][.] (2)


_Ïƒ(x) = arg max_
_Ïƒ>0_


It is of course not possible to optimize for this particular function since it is not known. It is also not
feasible to run the Monte-Carlo sampling for each Ïƒ, because that is too costly and moreover due


-----

**Algorithm 1 Data dependent certification (Alfarra et al., 2020)**

**function OPTIMIZESIGMA(F, x, Î², Ïƒ0, M, K):**

**for k = 0, . . ., K do**

sample Î´1, . . ., Î´M (0, I)

_M_ _âˆ¼N_


_Ï†(Ïƒk) =_


_F_ (x + ÏƒÎ´i)
_i=1_

P


_EË†A(Ïƒk) = maxC Ï†(Ïƒk)C_


_EË†B(Ïƒk) = maxC=A Ï†(Ïƒk)C_
_Ì¸_
_R(Ïƒk) =_ _[Ïƒ]2[k]_ [(Î¦][âˆ’][1][( Ë†]EA(Ïƒk)) âˆ’ Î¦[âˆ’][1]( E[Ë†]B(Ïƒk)))

_Ïƒk+1 â†_ _Ïƒk + Î²âˆ‡Ïƒk_ _R(Ïƒk)_

_Ïƒ[âˆ—]_ = ÏƒK
**return Ïƒ[âˆ—]**

to stochasticity, it would lead to discontinuous function. Treatment of this problem is probably the
most pronounced difference between the works of Alfarra et al. (2020) and Chen et al. (2021).

Alfarra et al. (2020) use the following easy observation: N (0, Ïƒ[2]I) â‰¡ _ÏƒN_ (0, I). Assume we haveM

_Î´i, i_ 1, . . ., M be i.i.d. sample from (0, I). Obviously, G(x, Ïƒ(x))A _M1_ _F_ (x + ÏƒÎ´i)A,
_âˆˆ{_ _}_ _N_ _âˆ¼_ _i=1_

since this is just the empirical mean of the theoretical expectation. Then, Expression 2 can beP
approximated as:


!!


Î¦[âˆ’][1]


_âˆ’_ Î¦[âˆ’][1]


(3)


_Ïƒ(x) = arg max_
_Ïƒ>0_


_F_ (x + ÏƒÎ´i)A
_i=1_

X


_F_ (x + ÏƒÎ´i)B
_i=1_

X


Here, M is the number of Monte-Carlo samplings used to approximate this function. Note, that this
function is a random realization of stochastic process in Ïƒ which is driven by the stochasticity in the
sample Î´i, i 1, . . ., M . To find the maximum of this function, authors furhter propose to use
_âˆˆ{_ _}_
simple gradient ascent, which is possible due to the simple differentiable form of Expression 3. This
differentiability is one of the main motivations to switch from hard to soft randomized smoothing.
Now, we are able to state the exact optimization algorithm of Alfarra et al. (2020):

Note, that being done in this way, this algorithm can be viewed as a stochastic gradient ascent. After
obtaining Ïƒ[âˆ—] _â‰¡_ _Ïƒ(x), authors further run the Monte-Carlo sampling to estimate the certified radius_
exactly as in Cohen et al. (2019), but with Ïƒ(x) instead of some global Ïƒ. Using this algorithm,
authors achieve significant improvement over the Cohen et al. (2019)â€™s results, particularly getting
rid of the first problem mentioned in Appendix A, the truncation issue. For the results, we refer to
Alfarra et al. (2020). We will now give several comments on this algorithm and this method.

To begin with, in this optimization, authors do not adjust the estimated expectations and therefore
donâ€™t use lower confidence bounds, but rather raw estimates. This is not incorrect, since these
estimates are not used directly for the estimation of certified radius, but it is inconsistent with the
resulting estimation. In other words, authors optimize for a slightly different function than they then
use. The difference is, however, not very big apart from extreme values of EA, where the difference
might be really significant.

To overcome slightly this inconsistence, authors further (without comment) use clamping of the
_EË†A(Ïƒk) and_ _E[Ë†]B(Ïƒk) on the interval [0.02, 0.98]. I.e. if_ _E[Ë†]A(Ïƒk) > 0.98, it will be set to 0.98_
and this is also taken into account in the computation of gradients. This way, authors get rid of
the inconvenient issue, that if G(x)A 1, then _E[Ë†]A(Ïƒk)_ 1 for Ïƒk 0, what might cause very
_âˆ¼_ _âˆ¼_ _âˆ¼_
big value of Î¦[âˆ’][1]( E[Ë†]A(Ïƒk)), yielding strong inconsistency with what would be obtained, if lower
confidence bound was used instead.

However, the clamping causes even stronger inconsistence in the end. Note, that if G(x)A 1, then
the true value of EA(Ïƒk) would be really close to 1, yielding high values of Î¦[âˆ’][1](EA(Ïƒ âˆ¼k)). This
value would be far better approximated by the lower confidence bound than with the clamping, since


-----

the lower confidence bound of 1 for M = 100000 and Î± = 0.001 is more than 0.9999, while the
clamped value is just 0.98. This makes small values of Ïƒ highly disadvantageous, since _[Ïƒ]2_ 0 as

_â†’[âˆ’]_
_Ïƒ_ 0, yet Î¦[âˆ’][1]( E[Ë†]A(Ïƒk)) is being stuck on Î¦[âˆ’][1](0.98). In other words, this way authors artificially
_âˆ’â†’_
force the resulting Ïƒ(x) to be big enough, s.t. E(Ïƒ(x))A 0.98. This assumption is not commented
in the article and might result in intransparent behaviour. â‰¤

Second of all, authors use M = 1 for their experiments. This can be interpreted as using batch size
1 in classical SGD. We suppose that this small batch size is suboptimal since it yields an insanely
high variance of the gradient.

Third of all, during the search for Ïƒ(x), it is not taken into account, whether the prediction is correct
or not. This is, of course, a scientifically correct approach, since we cannot look at the label of the
test sample before the very final evaluation. However, it is also problematic, since the function in
Expression 2 might attain its optimum in such a Ïƒ(x), which leads to misclassification. This could
have been avoided if constant Ïƒ was used instead.

To further illustrate this issue, assume F (x) = 1(B1(0)), i.e. F (x) predicts class 1 if and only
if âˆ¥xâˆ¥â‰¤ 1, otherwise predicts class 0. Assume we are certifying x â‰¡ 0 and assume that Ïƒ0 in
Algorithm 1 is initialized such that class 0 is already dominating. Then, we will have positive
gradient _Ïƒk_ _R(Ïƒk) in all steps, because F_ (ÏƒÎ´i) is obviously non-increasing, so the number of
_âˆ‡_
points classified as class 1 for fixed sample Î´i, i 1, . . ., M is decreasing, yielding _E[Ë†]A(Ïƒk) non-_
_âˆˆ_
decreasing in Ïƒk, while _[Ïƒ]2[k]_ [strictly increasing in][ Ïƒ][k][. This way, the][ Ïƒ][k][ will diverge to][ âˆž] [for][ k][ âˆ’]â†’âˆž.

However, point x â‰¡ 0 is classified as class 1, yielding misclassification which is, moreover, assigned
very high certified radius.

This issue is actually even more general - the function in Expression 2 does in most cases (assuming
infinite region R[N] ) not possess global maximum, because usually

_Ïƒ_
lim
_Ïƒ_ 2 [(Î¦][âˆ’][1][(][G][(][x, Ïƒ][(][x][))][A][)][ âˆ’] [Î¦][âˆ’][1][(][G][(][x, Ïƒ][(][x][))][B][)) =][ âˆž][.]
_âˆ’â†’âˆž_

This can be seen, for instance, easily for the F (x) = 1(B1(0)), but it is the case for any hard
classifier, for which one region becomes to have dominating area as the radius around some x0 goes
to infinity. This is because, if some region becomes to be dominating (for instance if all other regions
are bounded), then _[Ïƒ]2_ [grows, while][ Î¦][âˆ’][1][(][G][(][x, Ïƒ][(][x][))][A][)][ âˆ’] [Î¦][âˆ’][1][(][G][(][x, Ïƒ][(][x][))][B][)][ either grows too, or]

stagnates, making the whole function strictly increasing with sufficiently high slope.

This issue also throws the hyperparameter K under closer inspection. What is the effect of this hyperparameter on the performance of the algorithm? From the previous paragraph, it seems, that this
parameter serves not only as the â€œ scaled number of epochsâ€, but also as some stability parameter,
which, however, does not have theoretical, but rather practical justification.

Another issue is, that the function in Expression 2 might be non-convex and might possess many
different local minima, from which not all (or rather just a few) are actually reasonable. Therefore,
the Algorithm 1 is very sensitive to initialization Ïƒ0.

However, probably the biggest issue of all is connected to the impossibility result showed in Section 2, which shows, that the Algorithm 1 actually yields invalid certified radiuses. Why it is so?

First of all, we must justify, that our impossibility result is applicable also for the soft randomized
smoothing. This is because classifiers of type F (x)C = 1(x âˆˆ _RC) for RC being decision region for_
class C are among applicable classifiers s.t. G(x, Ïƒ)A = EA. With such classifiers, however, there
we can construct the worst-case classifiersis no difference between soft and hard smoothing and moreover F _[âˆ—]_ exactly as in our setup and therefore the same worst- EA â‰¡ _pA from our setup. This way_
case classifiers and subsequent adversarial examples are applicable here as well. In other words,
for fixed value of soft smoothed G(x, Ïƒ)A = EA we can denote pA = EA and find the worst-case
hard classifierTheorem 3 in some queried point F defined as indicator of the worst-case ball, which will yield x1. _EB â‰¡_ P1(B) from

As we have seen in previous paragraphs, the resulting Ïƒ(x) yielded in Algorithm 1 is very instable
and stochastic - it depends heavily on F, Ïƒ0, K, Î², M and of course Î´i, i 1, . . ., M for each
_âˆˆ{_ _}_
iteration of the for cycle. Now, for instance for CIFAR10 and pA = 0.99, we have the minimal
possible ratio _[Ïƒ]Ïƒ[0]1_ [equal to more than][ 0][.][96][. It is hard to believe, that such instable, highly stochastic]

and non-regularized (except for K, Î²) method will yield Ïƒ(x) sufficiently slowly varying such that


-----

Figure 14: The theoretical certified radius as in Expression 2. The function is monotonically increasing on interval [0, 100] and will further be increasing too.

within the certified radius around x0, there will be no x1 for which Ïƒ1 deviates more than by this
strict threshold from Ïƒ0. This is even more pronounced on ImageNet, where the minimal possible
ratio _[Ïƒ]Ïƒ[1]0_ [is above 0.99 for any][ p][A][ or][ E][A][.]

Even without the help of curse of dimensionality, we can construct a counterexample for which the
algorithm will not yield valid certified radius. Assume again F (x) = 1(B1(0)) and assume modest
dimension N = 2. Assume we try to certify point x0 [50, 0]. Then, the theoretical Ïƒ-dependent
function from Equation 2 is depicted on Figure 14. _â‰¡_

We can see, that the resulting Ïƒ(x0) will be as big as our regularizers K and Î² in Algorithm 1 will
allow. Therefore, if we run the algorithm for K high-enough, surely the resulting certified radius
for instance, then thewill be far bigger than 50. However, if we certify the point Ïƒ-dependent certified radius in Expression 2 will be decreasing in this x0 â‰¡ [0, 0] and we start with Ïƒ0 = 0 Ïƒ.250,,
yielding Ïƒ(x0) < 0.25, which will result in classification of class 1. This point [0, 0] lies within the
â€œcertifiedâ€ range of [50, 0], yet it is not classified the same, because, obviously, [50, 0] is classified
as class 0. This is therefore a counterexample to the validity of Alfarra et al. (2020)â€™s certification
method and their results.

Note that even though our counterexample is a bit â€œextremeâ€ and one could argue that in practice
such a situation would not occur, we must emphasize, that this counterexample is constructed even
without the help of the curse of dimensionality. In practice, it fully suffices, that for x0 and some
certified radius R in x0, there exists x1 within the range of this certified radius, s.t. Ïƒ1 is quite
dissimilar to Ïƒ0. If such situation occurs, then R surely is not a valid certified radius.

C.3 THE WORK OF CHEN ET AL. (2021)

The methodology of Chen et al. (2021) is rather similar to that of Alfarra et al. (2020). The biggest
difference consists in the optimization of Expression 2.

Instead of stochastic gradient descent, they use more sophisticated version of grid search - so called
_multiple-start fast gradient sign search. Simply speaking, this method first generates a set of pairs_
(Ïƒ0, s)i, i 1, . . ., K and then for each of the i runs, it runs a j-while cycle, where in each step j,
_âˆˆ{_ _}_
it increases Ïƒj[2] [=][ Ïƒ]0[2] [+][ js][ to][ Ïƒ]j[2]+1 [=][ Ïƒ]0[2] [+ (][j][ + 1)][s][ and checks, whether the][ Ïƒ][-dependent empirical]
certified radius in Expression 3 increases or not. If yes, they continue until j is above some threshold
_T_, if not, they break and report Ïƒi as the Ïƒj from the inner step where while cycle was broken. After
obtaining Ïƒi for i âˆˆ{1, . . ., K}, they choose Ïƒ(x) to be the one, that maximizes Expression 3.
More concretely, their multiple-start fast gradient sign search algorithm looks as follows:

It is not entirely clear from the text of Chen et al. (2021), how exactly are lk, sk sampled, but it is
written there, that the interval for l is [1, 16] and for s it is (âˆ’1, 1). Moreover, the authors donâ€™t


-----

**Algorithm 2 Instance-wise multiple-start FGSS (Chen et al., 2021)**

**function OPTIMIZESIGMA(F, x, Ïƒ0, M, K, T** ):

generate (lk, sk), k 1, . . ., K
_âˆˆ{_ _}_
**for k = 1, . . ., K do**

sample Î´1, . . ., Î´M (0, lkÏƒ0[2][I][)]

_M âˆ¼N_

_Ï†([âˆš]lkÏƒ0) =_ _M1_ _F_ (x + Î´i)

_i=1_

_EË†A([âˆš]lkÏƒ0) = maxP_ _C Ï†([âˆš]lkÏƒ0)C_
_R([âˆš]lkÏƒ0) =_ _lkÏƒ0Î¦[âˆ’][1]( E[Ë†]A([âˆš]lkÏƒ0))_

_[âˆš]_

_mk = R([âˆš]lkÏƒ0)_
**whilesample lk âˆˆ Î´[11, T, . . ., Î´] do** _M_ (0, (lk + sk)Ïƒ0[2][I][)]

_âˆ¼NM_

_Ï†([âˆš]lk + skÏƒ0) =_ _M1_ _F_ (x + Î´i)

_i=1_

_EË†A([âˆš]lk + skÏƒ0) = maxP_ _C Ï†([âˆš]lk + skÏƒ0)C_
_R([âˆš]lk + skÏƒ0) =_ _lk + skÏƒ0Î¦[âˆ’][1]( E[Ë†]A([âˆš]lk + skÏƒ0))_

_[âˆš]_

**if R([âˆš]lk + skÏƒ0) â‰¥** _R([âˆš]lkÏƒ0) then_

_lmk â†k =l Rk +([âˆš] slkk + skÏƒ0)_

**else**

break

_Ïƒ(x) =_ max
_kâˆˆ{1,...,K}[m][k]_

**return Ïƒ(x)**


provide the code and from the text, it seems, that they donâ€™t use lower confidence bounds during
the evaluation of certified radiuses, what we consider to be a serious mistake (if really the case).
However, we add some comments to this method regardless of the lower confidence bounds.

Generally, this method possesses most of the disadvantages mentioned in Section C.2. They use the
same function for optimization, the Expression 2 and its empirical version 3. This means, that the
method suffers from having several local optima, having no global optimum in general (and in most
cases with limit infinity). Similarly like before, here is also no control over the correctness of the
prediction, i.e. many or all local optima might lead to misclassification.

On the other hand, in this paper authors use M = 500 (the effective batch size), which is definitely
more reasonable than M = 1 as in Alfarra et al. (2020). Furthermore, they use multiple initializations, making the optimization more robust and improving the chances to obtain global, or at least
very good local minimum.

However, the main problem, the curse of dimensionality yielding invalid results is even more pronounced here. Unlike the â€œcontinuous approachâ€ in Alfarra et al. (2020), here authors for each x0
sample just some discrete grid (more complex, since there are more initializations) of possible values of Ïƒ(x). For instance, if s = 1, then the smallest possible ratio between two consecutive lâ€™s
in the Algorithm 2 is _âˆš15/4 âˆ¼_ 0.97, making it impossible to certify some x1 w.r.t. x0 if for both

_sis randomly sampled from = 1 and l0 Ì¸= l1 on ImageNet and also for a lot of samples on CIFAR10. Of course, the fact that (âˆ’1, 1) makes this counter-argumentation more difficult, but it is, again, s_
highly unlikely that this highly stochastic method without control over Ïƒ(x) would yield function
with sufficiently small semi-elasticity. Therefore also the impressive results of Chen et al. (2021)
are, unfortunately, scientifically invalid.

D IMPLEMENTATION DETAILS

Even though our algorithm is rather easy, there are some perks that should be discussed before one
can safely use it in practice. First, we show the actual Algorithm 3


-----

**Algorithm 3 Pseudocode for certification and prediction of my method based on Cohen et al. (2019)**

_# evaluate g at x0_
**function PREDICT(f, Ïƒ0, x0, n, Î±):**

counts SampleUnderNoise(f, x0, n, Ïƒ0)
_â†âˆ’_

_cË†A, Ë†cB_ two top indices in counts

_nA, nB â†âˆ’_ counts(cA), counts(Ë†cB)

**if BinomPValue â†âˆ’** (nA, nA + nB, 0.5) â‰¤ _Î± then return Ë†cA_

**else return ABSTAIN**


_# certify the robustness of g around x0_
**function CERTIFY(f, Ïƒ0, x0, n0, n, Î±):**

counts0 SampleUnderNoise(f, x0, n0, Ïƒ0)
_â†âˆ’_

_cË†A_ top index in counts0

counts â†âˆ’ SampleUnderNoise(f, x0, n, Ïƒ0)
_â†âˆ’_

_pA_ LowerConfBound(counts[Ë†cA], n, 1 _Î±)_
_â†âˆ’_ _âˆ’_

**if** _pA_ _>_ 1/2 **then** **return** prediction _cË†A_ and radius
ComputeCertifiedRadius(Ïƒ0, r, N, pA, num steps)

**else return ABSTAIN**


**function COMPUTECERTIFIEDRADIUS(Ïƒ0, r, N, pA, num steps)**

radiuses â†âˆ’ linspace(num space)

**for R in radiuses do**

xi biggerÏƒÏƒ1211 â† â†âˆ’âˆ’ _ÏƒÏƒ00 exp( exp(rRâˆ’Î¾rR>)_ ()R, Ïƒ11)
_â†_
xi lower _Î¾<(R, Ïƒ12)_
_â†_
**if max{xi bigger, xi lower} > 0.5 then BREAK**

**return R**

Note that the function ComputeCertifiedRadius is a bit more complicated than depicted in
Algorithm 3. We donâ€™t use a simple for-loop, but rather quite an efficient search method.

Theoretically speaking, this algorithm works perfectly. However, in practice, it is a bit problematic. The issue is, that since we use Ïƒ11 and Ïƒ12, which are extremely close to Ïƒ0 for small tested
radiuses R, the NCCHSQ functions will get extremely high inputs, making the results numerically
instable. To prevent this, we use a simple trick. Since the more extreme Ïƒ1 will we assume in
evaluation at particular distance R, the worse for us, we can prevent numerical issues simply by
putting Ïƒt < Ïƒ0 and ÏƒT > Ïƒ0 to be maximal and minimal used Ïƒâ€™s in our evaluation, i.e. the
true Ïƒ used will be min _Ïƒt, Ïƒ0 exp(_ _rR)_ and max _ÏƒT, Ïƒ0 exp(rR)_ . This way, we avoid nu_{_ _âˆ’_ _}_ _{_ 1 _}_
merical issues, because we can put Ïƒt, ÏƒT to be s.t. _Ïƒ0[2][âˆ’][Ïƒ]t[2]_ [is not too big and in the same time]

maintainting the correct certification thanks to the Lemma 6. The problems of this workarounds
are first that it decreases the certification power, since it assumes Ïƒ1â€™s that are even worse than the
theoretically guaranteed worst-case possibilities and second, more importantly, that it requires some
engineering to design the Ïƒt, ÏƒT designs. It is submoptimal to put one constant value for these
thresholds, because the numerical problems occur at different ratio thresholds of Ïƒ1/Ïƒ0 for different
class probabilities pA and the dimension N . This requires to design a specific Ïƒt(pA) and ÏƒT (pA)
functions for each dimension N which we want to apply. For instance, we use Ïƒt(pA) = 0.9993 +
0.001 log10(pB), and ÏƒT (pA) = 1/Ïƒt(pA) for CIFAR10, while for MNIST we use Ïƒt(pA) =
0.9988 + 0.001 log10(pB), and ÏƒT (pA) = 1/Ïƒt(pA). To design such functions, one needs to plot
plot real probability of a ball with fixed variances as fcn of dist function, which computes the Î¾ functions, for particular N and several values of pA and look, whether
it computes correctly. As an example, we provide such a plots for well and ill working setups on
Figure 15.

Another performance trick is to not evaluate Î¾ for each Ri, where Ri is i-th grid point of evaluation,
but rather evaluate sequentially Ri2, i.e. just every i[2]-th point, until we reach value > 0.5 and then
to search just the interval [(i 1)[2], i[2]], where i is the first iteration for which Î¾>(Ri2 _, Ïƒ1)_ 0.5.
_âˆ’_ _â‰¥_


-----

Figure 15: Well and ill working function
plot real probability of a ball with fixed variances as fcn of dist,
which computes the Î¾ functions. The coding is [Ïƒ0, Ïƒ1, N, pA].

E MORE TO EXPERIEMNTS AND ABLATIONS

Before we present our further results, we must emphasize that our certification procedure is barely
any slower than that of Cohen et al. (2019). More specifically, given 100000 iterations of montecarlo sampling, certification of one sample using Cohen et al. (2019)â€™s algorithm on CIFAR10 takes
_âˆ¼_ 15 seconds on our machine, while certification of a sample using our Algorithm 3 takes 15 âˆ’ 20
seconds depending on the Ïƒb, r setup. If at least one of Ïƒb and r is not small, then our method runs
practically instantly. If both parameters are small, then one evaluation can take up to 5 seconds
depending on the exact value of parameters and on the pA. Note, that this part of the certification
is dimension-independent and therefore can run in the same time also on much higher-dimensional
problems.

Besides the actual certification, we have to compute Ïƒ(x) for each of the test examples. This part of
the algorithm is being executed before the actual certification and usually takes around 1 minute on
our machine and on CIFAR10.

All in all, even in the really worst-case scenario, our method runs at most 1/3-times longer than
the old method on CIFAR10. On MNIST, the ratio between our run and the original run is higher,
since MNIST is smaller-dimensional problem. However, since our part of evaluation is practically
independent of the setup (except the values of Ïƒb and r, which, however, can yield just some upperbounded amount of slow-down), our algorithm does not bring any added asymptotic time complexity.

E.1 HOW TO CHOOSE THE HYPERPARAMETERS?

Our design of Ïƒ(x) function defined in Equation 1 uses several hyperparameters. These are: r for
the rate, m for the scaling, Ïƒb for the base sigma and k for the k-nearest neighbors. How do we
choose these hyperparameters?

The m parameter depends on our goals. We can set it so that Ïƒ(x) achieves lowest values at Ïƒb by
setting it so that it is roughly equal to the minimal distance from k nearest neighbors across, for
instance, training samples. Other possibility is to set it so that it is roughly equal to the average
distance from k nearest neighbors, to ensure that the average Ïƒ(x) will roughly correspond to the
_Ïƒb._

The k parameter needs to be set with two objectives in mind. Firstly, it would be unwise to set it too
small, because then the distance from k nearest neighbors would be too noisy. On the other hand, we
donâ€™t want it too high, because then it will not be changing fast enough with changing the position of
_x. The suitable value can be obtained by looking at histograms of average distances from k nearest_
neighbors and choosing the k for which the histogram is enough scattered, but it is not too small.


-----

Figure 16: Comparison of certified accuracy plots for Cohen et al. (2019) and our work. For each
plot, the same base model f is used for evaluation.

|Col1|Ïƒ = 0.12|Ïƒ = 0.25|Ïƒ = 0.50|
|---|---|---|---|
|r = 0.00|0.831|0.766|0.658|
|r = 0.005|0.830|0.766|0.654|
|r = 0.01|0.828|0.762|0.649|
|r = 0.015|0.826|-|-|


_Ïƒ = 0.12_ _Ïƒ = 0.25_ _Ïƒ = 0.50_

_r = 0.00_ 0.831 0.766 0.658

_r = 0.005_ 0.830 0.766 0.654

_r = 0.01_ 0.828 0.762 0.649

_r = 0.015_ 0.826 - 

Table 6: Clean accuracies for Cohenâ€™s models and our non-constant Ïƒ(x) models.

|Col1|Ïƒ = 0.12|Ïƒ = 0.25|Ïƒ = 0.50|
|---|---|---|---|
|r = 0.00|0.084|0.108|0.131|
|r = 0.005|0.086|0.112|0.135|
|r = 0.01|0.088|0.119|0.142|


_Ïƒ = 0.12_ _Ïƒ = 0.25_ _Ïƒ = 0.50_

_r = 0.00_ 0.084 0.108 0.131

_r = 0.005_ 0.086 0.112 0.135

_r = 0.01_ 0.088 0.119 0.142


Table 7: Standard deviations of class-wise accuracies for different levels of Ïƒ and r.

The r parameter needs to be chosen so that we can have some significant advantage over constant
smoothing, but it cannot be too big, because otherwise the curse of dimensionality would apply. The
value can be decided either by trial and error, or by plotting the certified radius given linear classifier,
or from Theorem 4, setting the rate low-enough so that within the expected certified radius range,
the ratio _[Ïƒ]Ïƒ[1]0_ [canâ€™t move anywhere near the theoretical thresholds implied by Theorem 4.]

The Ïƒb is the base Ïƒ and should be used according to the level of smoothing variance we want to
use. More discussion on this can be found in Cohen et al. (2019).

E.2 COMPARISON WITH COHEN ET AL. (2019) METHODOLOGY ON CIFAR10 DATASETS

Here, we compare Cohen et al. (2019)â€™s evaluations for Ïƒ = 0.12, 0.25, 0.50 with our evaluations
directly on models trained by Cohen et al. (2019), setting Ïƒb = Ïƒ, r = 0.005, 0.01 and 0.015 for
_Ïƒb = Ïƒ = 0.12, k = 20 and m = 5. In this way, the levels of Ïƒ(x) used in direct comparison will_
rise from the values roughly equal to Cohen et al. (2019)â€™s constant Ïƒ to higher values. The results
are depicted in Figure 16.

Note, that this evaluation is being done on the models trained directly by Cohen et al. (2019) and
therefore the variance of Gaussian data augmentation is not entirely consistent with the optimal
variance that should be used for non-constant Ïƒ, which should be either the same, Ïƒ(x) or constant,
but in average equal to Ïƒ(x). The results are similar as in the Section 4. Note, that for Ïƒb =
_Ïƒ = 0.50, the curse of dimensionality becomes most pronounced, as explained in Appendix B._
Further, we provide the Tables 6, 7, where the clean accuracies and class-wise standard deviations
are displayed.

The results are, again, similar as in the section 4.


-----

Figure 17: Comparison of certified accuracy plots for Cohen et al. (2019) and our work, MNIST.
For each plot, the same base model f is used for evaluation. The term trr stands for train-time rate,
will be discussed later and can be ignored now.

|Col1|Ïƒ = 0.12|Ïƒ = 0.25|Ïƒ = 0.50|
|---|---|---|---|
|r = 0.00|0.9913|0.9910|0.9888|
|r = 0.005|0.9914|0.9912|0.9885|
|r = 0.01|0.9914|0.9910|0.9887|
|r = 0.02|0.9914|0.9912|0.9876|
|r = 0.05|0.9914|0.9906|0.9836|


_Ïƒ = 0.12_ _Ïƒ = 0.25_ _Ïƒ = 0.50_

_r = 0.00_ 0.9913 0.9910 0.9888

_r = 0.005_ 0.9914 0.9912 0.9885

_r = 0.01_ 0.9914 0.9910 0.9887

_r = 0.02_ 0.9914 0.9912 0.9876

_r = 0.05_ 0.9914 0.9906 0.9836


Table 8: Clean accuracies for Cohenâ€™s models and our non-constant Ïƒ(x) models on MNIST.

|Col1|Ïƒ = 0.12|Ïƒ = 0.25|Ïƒ = 0.50|
|---|---|---|---|
|r = 0.00|0.677|0.729|0.909|
|r = 0.005|0.659|0.735|0.905|
|r = 0.01|0.659|0.722|0.9318|
|r = 0.02|0.659|0.713|0.960|
|r = 0.05|0.715|0.796|1.159|


_Ïƒ = 0.12_ _Ïƒ = 0.25_ _Ïƒ = 0.50_

_r = 0.00_ 0.677 0.729 0.909

_r = 0.005_ 0.659 0.735 0.905

_r = 0.01_ 0.659 0.722 0.9318

_r = 0.02_ 0.659 0.713 0.960

_r = 0.05_ 0.715 0.796 1.159


Table 9: Standard deviations of class-wise accuracies for different levels of Ïƒ and r. The printed
values are multiples of 100 of the real standard deviations.

E.3 COMPARISON WITH COHEN ET AL. (2019) METHODOLOGY ON MNIST DATASETS

Here, we present similar comparison as in Subsection E.2, but on MNIST and with models trained
by us. Again, the setup is similar as in the Section 4. We compare Ïƒ = Ïƒb = 0.12, 0.25, 0.50 with
test-time rates r = 0.005, 0.01, 0.02, 0.05 and train-time level of Ïƒ again equal to Ïƒ = Ïƒb. It is
important to note, that we use different normalization constant m in the MNIST case. In CIFAR10,
we set m = 5, in MNIST, the suitable m is 1.5. This way we assure, that the smallest Ïƒ(x) values
in the test set will roughly equal the Ïƒb = Ïƒ. The certified accuracy plots are depicted on Figure 17.
We also add the clean accuracy table and class-wise clean accuracies standard deviation table (8, 9).

All the results are, again, very similar to those presented in Section 4, even though the gain in
certified accuracies is marginally worse, since our evaluations run on models trained with in average
smaller train-time data-augmentation standard deviation Ïƒb = Ïƒ.

E.4 INVESTIGATION OF THE EFFECT OF TRAINING WITH INPUT-DEPENDENT GAUSSIAN
AUGMENATATION

It has been shown by many works, that apart from a good test-time certification method, also the
appropriate training plays a very important role in the final robustness of our smoothed classifier g.
Already Cohen et al. (2019) realize this and propose to train with gaussian data augmentation with
constant Ïƒ. They experiment with different levels of Ïƒ during training and conclude that training
with the same level of Ïƒ that will be later used in the test time is usually the most suitable option.


-----

Figure 18: The certified accuracies of our procedure on CIFAR10 for Ïƒb = 0.12, 0.25, 0.50, rate
_r = 0.01 and training rate trr = 0.0, 0.01, 0.04, 0.1._

The question of best-possible training to boost the certified robustness didnâ€™t stay without the interest of different researchers. Both Zhai et al. (2020) and Salman et al. (2019) try to improve the
way of training and propose two different, yet interesting and effective training methods. While
Zhai et al. (2020) manage to incorporate the adversarial robustness into the training loss function,
therefore training directly for the robustness, Salman et al. (2019) propose to use adversarial training
to achieve more robust classifiers.

Both Alfarra et al. (2020) and Chen et al. (2021) already propose to use training with input-dependent
_Ïƒ as the variance of gaussian data augmentation. Both of them proceed similarly as during test time_

-  to obtain training Ïƒ(x), they optimize for such, that would maximize the certified accuracy of
training samples.

In this section, we propose and test our own training method. We propose to use again gaussian
data augmentation with input-dependent Ïƒ(x), but we suggest to use the simple Ïƒ(x) defined in
Equation 1. In other words, we suggest using the same Ïƒ(x) during training as during testing (up to
parametrization, which might differ).

Note, that, unlike the certification, the training procedure does not require any mathematical analysis
nor certification. It is totally up to us how we train the base classifier f and the way of training does
not influence the validity of subsequent certification guarantees during test time. However, it is good
to have a reasonable training procedure, because otherwise, we would achieve a satisfactory model
neither in terms of clean accuracy nor in terms of adversarial robustness.

In the subsequent analysis, we evaluate and compare our certification procedures on models trained
with different training parametrizations. For this particular section, we run the comparison only on
the CIFAR10 dataset. For each test-time Ïƒb, r, we evaluate our method with these parameters on
base models f trained with the same Ïƒb, but different level of training rate trr. The training rate
_trr plays exactly the same role as the evaluation rate r but is used exclusively during training. Note,_
that this makes our Ïƒ(x) different during training and testing since it is parametrized with different
rates.

On the Figure 18 we plot evaluations on CIFAR10 of our method for rate 0.01, all levels of Ïƒb =
0.12, 0.25, 0.50 and each of these test-time setups is evaluated on 4 different levels of train-time rate
_trr = 0.0, 0.01, 0.04, 0.1._

From the results, we judge, that our training procedure works satisfactorily well. It can generally
outperform the constant Ïƒ training, yet the standard accuracy vs. robustness trade-off is present in
some cases. If we train with small train-time rate, the improvement of the certified accuracies is
not pronounced (the case for Ïƒb = Ïƒ = 0.50 is slightly misleading, since such a configuration
is just a result of the variance of clean accuracy w.r.t different traning runs) enough, but we also
donâ€™t lose almost any clean accuracy. Increasing the rate to trr = 0.04 results in much more
pronounced improvements in high certified accuracies, yet also comes at a prize of clean accuracy
drop, especially for large Ïƒ levels. Even bigger training rate, such as trr = 0.1 seems to be too big
and does not bring almost any improvement over the rate trr = 0.04, yet loses a large amount of
clean accuracy.

These results suggest, that the input-dependent training with a carefully chosen training rate for Ïƒ(x)
can lead to significant improvements in certifiable robustness. However, it is important to note, that


-----

|Col1|Ïƒ = 0.12|Ïƒ = 0.25|Ïƒ = 0.50|
|---|---|---|---|
|trr = 0.00|0.084|0.107|0.153|
|trr = 0.01|0.078|0.099|0.126|
|trr = 0.04|0.068|0.081|0.117|
|trr = 0.1|0.088|0.099|0.230|


_Ïƒ = 0.12_ _Ïƒ = 0.25_ _Ïƒ = 0.50_

_trr = 0.00_ 0.084 0.107 0.153

_trr = 0.01_ 0.078 0.099 0.126

_trr = 0.04_ 0.068 0.081 0.117

_trr = 0.1_ 0.088 0.099 0.230


Table 10: Standard deviations of class-wise accuracies for different levels of Ïƒ and trr, under constant rate r = 0.01.

the optimal trr seems to be dependent on the Ïƒb, therefore for each value of Ïƒb, some effort has to
be invested to find the optimal hyperparameters.

Besides, we were also interested, whether using an input-dependent Ïƒ(x) during training influences
the class-wise accuracy balance. In Table 10 we report the standard deviations of class-wise accuracies.

We can observe, that unlike the pure input-dependent evaluation, the input-dependent training is
partially capable of mitigating the effects of the shrinking. For instance, the trr = 0.04 for Ïƒb =
0.12 provides obvious improvement in establishing class-wise balance. Similarly successful are
trainings with trr = 0.01 for Ïƒb = 0.12 and both trr = 0.01, 0.04 for Ïƒb = 0.25. Also for
_Ïƒ = 0.50 the mitigation is present for small-enough training rates. However, we must emphasize,_
that if we use too big training rate, the disbalance between class accuracies will be re-established
and in some cases even magnified. Therefore, we must be careful to choose the appropriate training
rate for the Ïƒb, r.

E.5 WHY DO WE NOT COMPARE WITH THE CURRENT STATE-OF-THE-ART?

Briefly speaking â€“ we could, but we donâ€™t consider it necessary. Since we claim just one type of
improvement over the Cohen et al. (2019)â€™s model (experiment-wise) and donâ€™t claim new state-ofthe-art training method, we didnâ€™t find it necessary to measure our strengths with methods of Salman
et al. (2019) and Zhai et al. (2020). It is obvious that we would outperform these methods in the
question of certified accuracy waterfalls anyway, since these methods focus on the training phase.
Since we do not outperform Cohen et al. (2019) neither in terms of the clean accuracies nor in terms
of class-wise accuracies, it is not our belief that we would outperform the two modern methods in
these metrics. Moreover, we find the comparison with Cohen et al. (2019) most structured, since we
extend the theory built by them.

E.6 ABLATIONS

Even though our results so far might look impressive, we canâ€™t claim that it is fully due to our
particular method until we exclude the possibility, that some different effects play an essential role
in the improvement over Cohen et al. (2019)â€™s work.

To investigate, whether our particular method dominates the contribution to the performance boost,
we conduct several ablation studies - first, we study the variance of our evaluations and trainings,
second, we study the effect of input-dependent test-time randomized smoothing, and third, we study
the effect of input-dependent train-time data augmentation.

E.6.1 VARIANCE OF THE EVALUATION

To find out, whether there is a significant variance in the evaluation of certified radiuses, we conduct
a simple experiment - we train a single model on CIFAR10 and evaluate our method on this model
for the very same setup of parameters multiple times. This way, the only present stochasticity is
in the Monte-Carlo sampling, which influences the evaluation of certified radiuses. We pick the
parameters as follows: Ïƒb = 0.50, r = 0.01, trr = 0.0, since the Ïƒb = 0.50 turns out to have
biggest variance in the training. The results are depicted in Figure 19.

From the results, it is obvious that the variance in the evaluation phase is absolutely negotiable.
Therefore, there is no need to run the same evaluation setup more times.


-----

Figure 19: The variance of evaluation. Parameters are Ïƒb = 0.50, r = 0.01, trr = 0.0, the evaluated
model is the same for all runs. There are 7 runs on CIFAR10.

Figure 20: The certified accuracies of our procedure on CIFAR10 for Ïƒb = 0.12, 0.25, 0.50, rate
_r = 0.01 and training rate trr = 0.0 evaluated on 9 different trained models for each of the setups._

|Col1|Ïƒ = 0.12|Ïƒ = 0.25|Ïƒ = 0.50|
|---|---|---|---|
|accuracy|0.61%|0.40%|1.86%|
|abstention rate|0.17%|0.34%|0.59%|
|misclassification rate|0.60%|0.24%|1.48%|


_Ïƒ = 0.12_ _Ïƒ = 0.25_ _Ïƒ = 0.50_

accuracy 0.61% 0.40% 1.86%

abstention rate 0.17% 0.34% 0.59%

misclassification rate 0.60% 0.24% 1.48%


Table 11: Standard deviations of clean accuracies, abstention rates and misclassification rates for 9
runs of each parameter configuration on CIFAR10.

E.6.2 VARIANCE OF THE TRAINING

To estimate the variance of the training, we train several models for one specific training setup
and evaluate them with the same evaluation setup (knowing, that there is no variance in the evaluation phase, this is equivalent to measuring directly the training variance). We pick our classical
non-constant Ïƒ(x) for the evaluation, but we train with constant variance data augmentation. The
concrete parameters we work with are: Ïƒb 0.12, 0.25, 0.50 _, r = 0.01, trr = 0.0 and we run 9_
trainings for each of these parameter configurations. Then we run full certification to not only see âˆˆ{ _}_
the variance in clean accuracy, but also the variance in the certified radiuses. The results are depicted
in Figure 20.

From the figures we see, that the variance of the training is strongly Ïƒb-dependent. Most volatile
clean accuracy is present for the case Ïƒb = 0.50. However, fortunately, the biggest variability is
present for the clean accuracy and the curves seem to be less scattered in the areas of high certified radiuses. The concrete standard deviations of clean accuracies are in Table 11. The standard
deviations of clean accuracies for MNIST dataset and the same parameters are in Table 12.


-----

|Col1|Ïƒ = 0.12|Ïƒ = 0.25|Ïƒ = 0.50|
|---|---|---|---|
|accuracy|0.036%|0.042%|0.044%|
|abstention rate|0.037%|0.027%|0.058%|
|misclassification rate|0.043%|0.029%|0.021%|


_Ïƒ = 0.12_ _Ïƒ = 0.25_ _Ïƒ = 0.50_

accuracy 0.036% 0.042% 0.044%

abstention rate 0.037% 0.027% 0.058%

misclassification rate 0.043% 0.029% 0.021%


Table 12: Standard deviations of clean accuracies, abstention rates and misclassification rates for 8
runs of each parameter configuration on MNIST.

Since the differences in accuracies of different methods are very subtle, it is hard to obtain statistically trustworthy results. For instance, given, that the standard deviation 0.4% is the true standard
deviation of the Ïƒb = 0.25 runs, we would need 16 runs to decrease it to a standard deviation of
0.1%, which might be considered to be precise-enough. To do the same in the case of Ïƒb = 0.50 on
CIFAR10, we would roughly need 400 runs to decrease the standard deviation below 0.1%. Therefore, the results we provide in the subsequent subsections, being the average of â€œjustâ€ 8 runs, have
to be taken just modulo variance in the results, which might still be considerable.

E.6.3 EFFECT OF INPUT-DEPENDENT EVALUATION

In this ablation study, we compare the certification method for particular Ïƒb, r = 0.01, trr = 0.0
with the constant-Ïƒ certification method with CÏƒb, r = 0.0, trr = 0.0, where C is an appropriate
constant. The motivation behind such an experiment is, that our Ïƒ(x) is generally bigger than Ïƒb, but
originally, we compare this method to constant Ïƒ = Ïƒb evaluation. Therefore, in average, samples
in our method enjoy bigger values of Ïƒ(x). Natural question is, whether we cannot obtain the
same performance boost using just the constant Ïƒ method with CÏƒb > Ïƒb set to such value, which
roughly corresponds to the average of Ïƒ(xi) for xi, i 1, . . ., T being the test set. The problem
_âˆˆ{_ _}_
of using bigger CÏƒb is, that we encounter performance drop and more severe case of shrinking,
but we need to check, to what extent is the performance drop present in the input-dependent Ïƒ(x)
method. Comparing the performance drops of larger constant CÏƒb and input-dependent Ïƒ(x), which
is in average larger (but in average the same as the CÏƒb), we will be able to answer, to what degree
is the usage of input-dependent Ïƒ(x) really justified. If we remind ourselves, that

_Ïƒ(x) = Ïƒb exp_ _r_ _x_ _xi_ _m_ _,_

ï£« ï£« _k_ ï£« _âˆ¥_ _âˆ’_ _âˆ¥ï£¶_ _âˆ’_ ï£¶ï£¶

_xiâˆˆNXk(x)_

ï£­ ï£­ [1] ï£­ ï£¸ ï£¸ï£¸

then we see, that the constant C we are searching for is the average (or rather median) value of


exp _r_ _x_ _xi_ _m_ _._

ï£« ï£« _k_ ï£« _âˆ¥_ _âˆ’_ _âˆ¥ï£¶_ _âˆ’_ ï£¶ï£¶

_xiâˆˆNXk(x)_

ï£­ ï£­ [1] ï£­ ï£¸ ï£¸ï£¸

Fortunately, empirically, the mean and median of the above expression are roughly equal for both
CIFAR10 and MNIST, so we are not forced to choose between them. For r = 0.01, m = 5,
we choose the rounded value of C = exp(0.05) on CIFAR10. For r = 0.01, m = 1.5 as in
MNIST, the constant is set to C = 1.035. In the end, the values of CÏƒ used in this experiment are
_CÏƒ = 0.126, 0.263, 0.53 for CIFAR10 and CÏƒ = 0.124, 0.258, 0.517 for MNIST. To obtain a fair_
comparison, though, we evaluate the input-dependent Ïƒ(x) evaluation strategy on models trained
with constant CÏƒb standard deviation of gaussian augmentation. This is because this level of Ïƒ is
equal to the mean value of the Ïƒ(x) and we believe, that such a training data augmentation standard
deviation is more consistent with our Ïƒ(x) function. We provide the plots of single-run evaluations
of certified accuracies for CIFAR10 in Figure 21 and for MNIST in Figure 22. The models on
which we evaluate differ because for the increased constant Ïƒ evaluations we needed to also use an
increased level of the training data augmentation variance.

From the figures, it is obvious, that our method is not able to outperform the constant Ïƒ method
using the same mean Ïƒ in terms of certified accuracy, not even for our strongest Ïƒb = 0.12. This fact
might not be in general bad news, if we demonstrated, that our method suffers from less pronounced
accuracy drop or less pronounced disbalance in class-wise accuracies. To find out, we measure


-----

Figure 21: The certified accuracies of our procedure on CIFAR10 for Ïƒb = 0.12, 0.25, 0.50, rate
_r = 0.01 and constant, yet increased CÏƒb training variance, compared to certified accuracies of_
the constant Ïƒ method for Ïƒ = Ïƒb = 0.12, 0.25, 0.50 and also Ïƒ = CÏƒb = 0.126, 0.265, 0.53.
Evaluated on a single training.

Figure 22: The certified accuracies of our procedure on MNIST for Ïƒb = 0.12, 0.25, 0.50, rate
_r = 0.01 and constant, yet increased CÏƒb training variance, compared to certified accuracies of_
the constant Ïƒ method for Ïƒ = Ïƒb = 0.12, 0.25, 0.50 and also Ïƒ = CÏƒb = 0.124, 0.258, 0.517.
Evaluated on a single training.

|Col1|Ïƒ = 0.12|Ïƒ = 0.25|Ïƒ = 0.50|
|---|---|---|---|
|r = 0.01, trs increased|0.852|0.780|0.673|
|r = 0.00 classical|0.851|0.792|0.674|
|r = 0.00 increased|0.853|0.780|0.673|


_Ïƒ = 0.12_ _Ïƒ = 0.25_ _Ïƒ = 0.50_

_r = 0.01, trs increased_ 0.852 0.780 0.673

_r = 0.00 classical_ 0.851 0.792 0.674

_r = 0.00 increased_ 0.853 0.780 0.673


Table 13: Clean accuracies for both input-dependent and constant Ïƒ evaluation strategies on CIFAR10.

|Col1|Ïƒ = 0.12|Ïƒ = 0.25|Ïƒ = 0.50|
|---|---|---|---|
|r = 0.01, trs increased|0.076|0.099|0.120|
|r = 0.00 classical|0.076|0.097|0.122|
|r = 0.00 increased|0.076|0.101|0.123|


_Ïƒ = 0.12_ _Ïƒ = 0.25_ _Ïƒ = 0.50_

_r = 0.01, trs increased_ 0.076 0.099 0.120

_r = 0.00 classical_ 0.076 0.097 0.122

_r = 0.00 increased_ 0.076 0.101 0.123


Table 14: Class-wise accuracy standard deviations for both input-dependent and constant Ïƒ evaluation strategies on CIFAR10.

average accuracies of the evaluation strategies from 8 runs for each, as well as average class-wise
accuracy standard deviations from 8 runs. The results are provided in Tables 13 and 14 for CIFAR10
and Tables 15 and 16 for MNIST.

As for CIFAR10, except for Ïƒ = Ïƒb = 0.25, the differences in accuracies between different evaluation strategies are so small, that we cannot consider them to be statistically significant. Even though
the difference for Ïƒ = Ïƒb = 0.25 is high, it is still not possible to draw some definite conclusions,
especially for the difference between the input-dependent Ïƒ(x) and the increased constant CÏƒb
evaluations. In general, it is not easy to judge, whether our method possesses some advantage (or
disadvantage) over the increased CÏƒb method in terms of clean accuracy. Similar conclusions can
be drawn in the context of the shrinking phenomenon. Here, the differences are also very small, but


-----

|Col1|Ïƒ = 0.12|Ïƒ = 0.25|Ïƒ = 0.50|
|---|---|---|---|
|r = 0.01, trs increased|0.9913|0.9905|0.9885|
|r = 0.00 classical|0.9914|0.9907|0.9886|
|r = 0.00 increased|0.9914|0.9904|0.9885|


_Ïƒ = 0.12_ _Ïƒ = 0.25_ _Ïƒ = 0.50_

_r = 0.01, trs increased_ 0.9913 0.9905 0.9885

_r = 0.00 classical_ 0.9914 0.9907 0.9886

_r = 0.00 increased_ 0.9914 0.9904 0.9885


Table 15: Clean accuracies for both input-dependent and constant Ïƒ evaluation strategies on MNIST.

|Col1|Ïƒ = 0.12|Ïƒ = 0.25|Ïƒ = 0.50|
|---|---|---|---|
|r = 0.01, trs increased|0.00757|0.00798|0.00929|
|r = 0.00 classical|0.00751|0.00778|0.00934|
|r = 0.00 increased|0.00750|0.00798|0.00925|


_Ïƒ = 0.12_ _Ïƒ = 0.25_ _Ïƒ = 0.50_

_r = 0.01, trs increased_ 0.00757 0.00798 0.00929

_r = 0.00 classical_ 0.00751 0.00778 0.00934

_r = 0.00 increased_ 0.00750 0.00798 0.00925


Table 16: Class-wise accuracy standard deviations for both input-dependent and constant Ïƒ evaluation strategies on MNIST. Printed are multiples of 100 of the real values.

Figure 23: The certified radiuses on CIFAR10 of the non-constant Ïƒ(x) method with rate r = 0.01,
but different training strategies. Used training strategies are input-dependent training with the same
_Ïƒ(x) function and constant-Ïƒ training with either Ïƒb or CÏƒb variance level. Evaluations are being_
done from single run.

unlike in the comparison with Cohen et al. (2019) models, where we evaluate our input-dependent
_Ïƒ(x) method on classifiers trained with inconsistent data-augmentation variance, here we observe_
the general trend, that our method is able to outperform the increased constant CÏƒb evaluation. This
is good news and it confirms our suspicion, that the bad results from Subsection E.2 could come
from the train-test Ïƒ inconsistency.

The results on MNIST suggest similar conclusions for the accuracy vs. robustness tradeoff. Similarly, the Ïƒ = Ïƒb = 0.12, 0.50 are not telling much, and for Ïƒ = Ïƒb = 0.25, the differences are
still rather small (yet the standard deviation of the results should be âˆ¼ 0.0001, so it is rather on the
edge). The conclusions for the shrinking phenomenon are a bit more pesimistic than in the case of
CIFAR10. Here we donâ€™t see any improvement over the constant Ïƒ, not even the one with increased
_Ïƒ level._

E.6.4 EFFECT OF INPUT-DEPENDENT TRAINING

In this last ablation study, we compare our input-dependent data augmentation for particular Ïƒb, r
and particular training rate trr with the constant CÏƒb data augmentation, where the training rate trr
is set to 0. The strategy for choosing the constant C is exactly the same as in the first experiment.
Particularly, we evaluate our method with r = 0.01 and Ïƒb = 0.12, 0.25, 0.50, trained with the
same level of Ïƒb and training rate trr = 0.01 with the evaluations using r = 0.01 and Ïƒb =
0.12, 0.25, 0.50 during test time, while during train time using training rate trr = 0.0, but using the
constant Ïƒ = 0.126, 0.263, 0.53 for CIFAR10 and Ïƒ = 0.124, 0.258, 0.517 for MNIST. This way,
we compensate for the â€œincreased levels of Ïƒ(x)â€ with respect to Ïƒb. We present our comparisons
in the Figure 23 for CIFAR10 and 24 for MNIST, providing the evaluations with r = 0.01, Ïƒb =
0.12, 0.25, 0.50 and the same Ïƒb and trr = 0.0 during train time as a reference.


-----

Figure 24: The certified radiuses on MNIST of the non-constant Ïƒ(x) method with rate r = 0.01,
but different training strategies. Used training strategies are input-dependent training with the same
_Ïƒ(x) function and constant-Ïƒ training with either Ïƒb or CÏƒb variance level. Evaluations are being_
done from single run.

|Col1|Ïƒ = 0.12|Ïƒ = 0.25|Ïƒ = 0.50|
|---|---|---|---|
|trr = 0.01|0.843|0.780|0.671|
|trr = 0.00 classical|0.849|0.790|0.670|
|trr = 0.00 increased|0.852|0.780|0.673|


_Ïƒ = 0.12_ _Ïƒ = 0.25_ _Ïƒ = 0.50_

_trr = 0.01_ 0.843 0.780 0.671

_trr = 0.00 classical_ 0.849 0.790 0.670

_trr = 0.00 increased_ 0.852 0.780 0.673


Table 17: Clean accuracies for both input-dependent and constant Ïƒ training strategies on CIFAR10.

|Col1|Ïƒ = 0.12|Ïƒ = 0.25|Ïƒ = 0.50|
|---|---|---|---|
|trr = 0.01|0.080|0.101|0.121|
|trr = 0.00 classical|0.080|0.105|0.135|
|trr = 0.00 increased|0.076|0.099|0.120|


_Ïƒ = 0.12_ _Ïƒ = 0.25_ _Ïƒ = 0.50_

_trr = 0.01_ 0.080 0.101 0.121

_trr = 0.00 classical_ 0.080 0.105 0.135

_trr = 0.00 increased_ 0.076 0.099 0.120


Table 18: Class-wise accuracy standard deviations for both input-dependent and constant Ïƒ training
strategies on CIFAR10.

|Col1|Ïƒ = 0.12|Ïƒ = 0.25|Ïƒ = 0.50|
|---|---|---|---|
|trr = 0.01|0.9912|0.9910|0.9883|
|trr = 0.00 classical|0.9914|0.9906|0.9884|
|trr = 0.00 increased|0.9913|0.9905|0.9885|


_Ïƒ = 0.12_ _Ïƒ = 0.25_ _Ïƒ = 0.50_

_trr = 0.01_ 0.9912 0.9910 0.9883

_trr = 0.00 classical_ 0.9914 0.9906 0.9884

_trr = 0.00 increased_ 0.9913 0.9905 0.9885


Table 19: Clean accuracies for both input-dependent and constant Ïƒ training strategies on MNIST.

|Col1|Ïƒ = 0.12|Ïƒ = 0.25|Ïƒ = 0.50|
|---|---|---|---|
|trr = 0.01|0.00757|0.00800|0.00947|
|trr = 0.00 classical|0.00743|0.00789|0.00929|
|trr = 0.00 increased|0.00757|0.00798|0.00929|


_Ïƒ = 0.12_ _Ïƒ = 0.25_ _Ïƒ = 0.50_

_trr = 0.01_ 0.00757 0.00800 0.00947

_trr = 0.00 classical_ 0.00743 0.00789 0.00929

_trr = 0.00 increased_ 0.00757 0.00798 0.00929


Table 20: Class-wise accuracy standard deviations for both input-dependent and constant Ïƒ training
strategies on MNIST.

The certified accuracy results for the CIFAR10 and the MNIST differ a bit. For CIFAR10 training
with rate r = 0.01 is does not overperform the constant CÏƒb training. For Ïƒb = 0.12, the constant
_CÏƒb training clearly outperforms the input-dependent training. For Ïƒb = 0.25, these two training_
strategies seem to have almost identical performances. For Ïƒb = 0.50, the input-dependent Ïƒ(x)
strategy outperforms the constant Ïƒ ones, but now we know, that it is purely due to the variance in
the training. On the other hand on MNIST, we either have very similar performance or even slightly
outperform the constant Ïƒ training.


-----

Looking at the accuracy and standard deviation Tables 17, 18, 19 and 20, we can deduce the following. In terms of clean accuracy, the input-dependent training strategy performs worst in most of the
cases, even though the differences in performance might not be statistically significant. We see, that
we would need far more evaluations to see some clear pattern. However, these results are definitely
not good news for the use of input-dependent Ïƒ(x) during training.

In terms of the class-wise accuracy standard deviation, we again see countering results for CIFAR10
and MNIST datasets. For CIFAR10 the input-dependent Ïƒ(x) clearly outperforms the smaller constant Ïƒb training method, particularly for Ïƒb = 0.50. However, the constant CÏƒb method seem to
outperform even the input-dependent Ïƒ(x). For MNIST, the smaller constant Ïƒb outperforms both
other methods, while they are rather similar.

Together with findings from previous sections, these results suggest, that usage of this particular
design of input-dependent Ïƒ(x) might not be worthy until a more precise evaluation is conducted.
However, the combination of input-dependent test-time evaluation with constant, yet increased traintime augmentation is possibly the strongest combination that can be achieved using input-dependent
sigma at all (especially for CIFAR10).

F PROOFS

**Lemma 17 (Neyman-Pearson). Let X, Y be random vectors in R[N]** with densities x, y. Let h :
R[N] _âˆ’â†’{0, 1} be a random or deterministic function. Then, the following two implications hold:_

1. If S = _z_ R[N] : _x[y][(]([z]z[)])_ for some t > 0 and P(h(X) = 1) P(X _S), then_
_âˆˆ_ _[â‰¤]_ _[t]_ _â‰¥_ _âˆˆ_

P(h(Y ) = 1)n _â‰¥_ P(Y âˆˆ _S)._ o

2. If S = _z_ R[N] : _x[y][(]([z]z[)])_ for some t > 0 and P(h(X) = 1) P(X _S), then_
_âˆˆ_ _[â‰¥]_ _[t]_ _â‰¤_ _âˆˆ_

P(h(Y ) = 1)n _â‰¤_ P(Y âˆˆ _S)._ o


_Proof. See Cohen et al. (2019)._

**Lemma 1: Out of all possible classifiers f such that Gf** (x)B _pB = 1_ _pA, the one, for which_
_Gf_ (x + Î´)B is maximized is the one, which predicts class B in a region determined by the likelihood â‰¤ _âˆ’_
ratio:

_B =_ _x_ R[N] : _[f][1][(][x][)]_ _,_
_âˆˆ_ _f0(x)_ _r_
 _[â‰¥]_ [1] 

where r is fixed, such that P0(B) = pB. Note, that we use B to denote both the class and the region
of that class.

_Proof. Let f be arbitrary classifier. To invoke the Neyman-Pearson Lemma 17, define h â‰¡_ _f_
(with the only difference, that h goes to {0, 1} instead of {A, B}). Moreover, let S â‰¡ _B and_
_X âˆ¼N_ (x, Ïƒ0[2][I][)][, Y][ âˆ¼N] [(][x][ +][ Î´, Ïƒ]1[2][I][)][. Let also][ f][ âˆ—] [classify][ S][ as][ B][. Then obviously,][ P][(][X][ âˆˆ] _[S][) =]_
PNeyman-Pearson Lemma 17, this will yield0(B) = pB. Since Gf (x)B â‰¤ _pB, we have P P((Yh âˆˆ(XS) = 1)) â‰¥_ P â‰¤(hp(YB ) = 1). Using directly the second part of. Rewritten in the words of
our setup, Gf âˆ— (x + Î´) _Gf_ (x + Î´).
_â‰¥_

**Theorem 2: If Ïƒ0 > Ïƒ1, then B is a N** -dimensional ball with the center at S> and radius R>:

_S> = x +_ _Ïƒ0[2]_ _Î´, R> =_ _Ïƒ0[2][Ïƒ]1[2]_ _Ïƒ0[2][Ïƒ]1[2]_ log _Ïƒ0_ + [2][Ïƒ]0[2][Ïƒ]1[2] log(r).

_Ïƒ0[2]_ 1 s (Ïƒ0[2] 1[)][2][ âˆ¥][Î´][âˆ¥][2][ + 2][N] _Ïƒ0[2]_ 1 _Ïƒ1_ _Ïƒ0[2]_ 1

 

_[âˆ’]_ _[Ïƒ][2]_ _[âˆ’]_ _[Ïƒ][2]_ _[âˆ’]_ _[Ïƒ][2]_ _[âˆ’]_ _[Ïƒ][2]_

If Ïƒ0 < Ïƒ1, then B is the complement of a N -dimensional ball with the center at S< and radius R<:


2Ïƒ0[4] _[âˆ’]_ _[Ïƒ]0[2][Ïƒ]1[2]_ _Ïƒ0[2][Ïƒ]1[2]_ log _Ïƒ1_

(Ïƒ1[2] 0[)][2][ âˆ¥][Î´][âˆ¥][2][ + 2][N] _Ïƒ1[2]_ 0 _Ïƒ0_



_[âˆ’]_ _[Ïƒ][2]_ _[âˆ’]_ _[Ïƒ][2]_


_S< = x_ _Ïƒ0[2]_ _Î´, R< =_
_âˆ’_ _Ïƒ1[2]_ 0

_[âˆ’]_ _[Ïƒ][2]_


0[Ïƒ]1[2] log(r).
_âˆ’_ _Ïƒ[2]1[2][Ïƒ][2]_ 0

_[âˆ’]_ _[Ïƒ][2]_


-----

_Proof. From spherical symmetry of isotropic multivariate normal distribution, it follows, that with-_
out loss of generality we can take Î´ â‰¡ (a, 0, . . ., 0). With little abuse of notation, let a refer to
(a, 0, . . ., 0) as well as âˆ¥(a, 0, . . ., 0)âˆ¥. With this, the B is a set of all x, for which:


_f1(x)_
_f0(x)_ _r_

_[â‰¥]_ [1] _[â‡]_

_r_

exp
(2Ï€)[N/][2]Ïƒ1[N]


#!


_âˆ’_ 2Ïƒ[1]0[2]


_âˆ’_ 2Ïƒ[1]1[2]


(x1 _a)[2]_ +
_âˆ’_


_x[2]i_
_i=1_

X


_x[2]i_
_i=2_

X


exp
(2Ï€)[N/][2]Ïƒ0[N]


_N_ _N_

1 _Ïƒ0_

1[2] (x1 âˆ’ _a)[2]_ + _i=2_ _x[2]i_ ! _âˆ’_ 2Ïƒ0[2] _i=1_ _x[2]i_ _[â‰¤]_ _[N][ log]_  _Ïƒ1_  + log(r) â‡â‡’

X X

_N_

_Ïƒ0_
_x[2]i_ [+ (][Ïƒ]0[2] 1[)][x][2]1 0[x][1][a][ +][ Ïƒ]0[2][a][2][ â‰¤] [2][NÏƒ]0[2][Ïƒ]1[2] [log] + 2Ïƒ0[2][Ïƒ]1[2] [log(][r][)]
_i=2_ _[âˆ’]_ _[Ïƒ][2]_ _[âˆ’]_ [2][Ïƒ][2]  _Ïƒ1_ 

X


(x1 _a)[2]_ +
_âˆ’_


2Ïƒ1[2]


(Ïƒ0[2] _[âˆ’]_ _[Ïƒ]1[2][)]_


Now assume Ïƒ0 > Ïƒ1 and continue:


_N_

_Ïƒ0_

(Ïƒ0[2] 1[)] _x[2]i_ [+ (][Ïƒ]0[2] 1[)][x]1[2] 0[x][1][a][ +][ Ïƒ]0[2][a][2][ â‰¤] [2][NÏƒ]0[2][Ïƒ]1[2] [log] + 2Ïƒ0[2][Ïƒ]1[2] [log(][r][)][ â‡]

_[âˆ’]_ _[Ïƒ][2]_ _i=2_ _[âˆ’]_ _[Ïƒ][2]_ _[âˆ’]_ [2][Ïƒ][2]  _Ïƒ1_ 

X

_N_

_x[2]i_ [+][ x]1[2] 2Ïƒ0[2] _ax1 +_ _a[2]Ïƒ0[2]_ 2N _Ïƒ0[2][Ïƒ]1[2]_ log _Ïƒ0_ + [2][Ïƒ]0[2][Ïƒ]1[2] log(r)
_i=2_ _[âˆ’]_ _Ïƒ0[2]_ 1 _Ïƒ0[2]_ 1 _â‰¤_ _Ïƒ0[2]_ 1  _Ïƒ1_  _Ïƒ0[2]_ 1 _â‡â‡’_

X _[âˆ’]_ _[Ïƒ][2]_ _[âˆ’]_ _[Ïƒ][2]_ _[âˆ’]_ _[Ïƒ][2]_ _[âˆ’]_ _[Ïƒ][2]_

2 _N_

_Ïƒ0[2]_ _Ïƒ0[2][Ïƒ]1[2]_ _Ïƒ0[2][Ïƒ]1[2]_ _Ïƒ0_ 0[Ïƒ]1[2]
x1 âˆ’ _Ïƒ0[2]_ 1 _a_ + _i=2_ _x[2]i_ _[â‰¤]_ (Ïƒ0[2] 1[)][2][ a][2][ + 2][N] _Ïƒ0[2]_ 1 log  _Ïƒ1_  + Ïƒ[2]0[2][Ïƒ][2] 1 log(r)

_[âˆ’]_ _[Ïƒ][2]_ X _[âˆ’]_ _[Ïƒ][2]_ _[âˆ’]_ _[Ïƒ][2]_ _[âˆ’]_ _[Ïƒ][2]_


Such inequality defines exactly the ball from the statement of the theorem. On the other hand, if
_Ïƒ0 < Ïƒ1:_


_N_

_Ïƒ1_

(Ïƒ1[2] 0[)] _x[2]i_ [+ (][Ïƒ]1[2] 0[)][x]1[2] [+ 2][Ïƒ]0[2][x][1][a][ âˆ’] _[Ïƒ]0[2][a][2][ â‰¥]_ [2][NÏƒ]0[2][Ïƒ]1[2] [log] 2Ïƒ0[2][Ïƒ]1[2] [log(][r][)][ â‡]

_[âˆ’]_ _[Ïƒ][2]_ _i=2_ _[âˆ’]_ _[Ïƒ][2]_  _Ïƒ0_  _âˆ’_

X

_N_

_x[2]i_ [+][ x]1[2] [+] 2Ïƒ0[2] _ax1_ _a[2]Ïƒ0[2]_ 2N _Ïƒ0[2][Ïƒ]1[2]_ log _Ïƒ1_ 0[Ïƒ]1[2] log(r)
_i=2_ _Ïƒ1[2]_ 0 _âˆ’_ _Ïƒ1[2]_ 0 _â‰¥_ _Ïƒ1[2]_ 0  _Ïƒ0_  _âˆ’_ _Ïƒ[2]1[2][Ïƒ][2]_ 0 _â‡â‡’_

X _[âˆ’]_ _[Ïƒ][2]_ _[âˆ’]_ _[Ïƒ][2]_ _[âˆ’]_ _[Ïƒ][2]_ _[âˆ’]_ _[Ïƒ][2]_

2 _N_

_x1 +_ _Ïƒ0[2]_ _a_ + _x[2]i_ 0 _[âˆ’]_ _[Ïƒ]0[2][Ïƒ]1[2]_ _Ïƒ0[2][Ïƒ]1[2]_ log _Ïƒ1_ 0[Ïƒ]1[2] log(r)
 _Ïƒ1[2]_ 0  _i=2_ _[â‰¥]_ [2]([Ïƒ]Ïƒ[4]1[2] 0[)][2][ a][2][ + 2][N] _Ïƒ1[2]_ 0  _Ïƒ0_  _âˆ’_ _Ïƒ[2]1[2][Ïƒ][2]_ 0

_[âˆ’]_ _[Ïƒ][2]_ X _[âˆ’]_ _[Ïƒ][2]_ _[âˆ’]_ _[Ïƒ][2]_ _[âˆ’]_ _[Ïƒ][2]_


This is exactly the complement of a ball from the second part of the statement of the theorem.

**Theorem 3:**

P0(B) = Ï‡[2]N (Ïƒ0[2] _Ïƒ0[2]_ 1[)][2][ âˆ¥][Î´][âˆ¥][2][, R]Ïƒ<,>[2]0[2] ! _, P1(B) = Ï‡[2]N_ (Ïƒ0[2] _Ïƒ1[2]_ 1[)][2][ âˆ¥][Î´][âˆ¥][2][, R]Ïƒ<,>[2]1[2] ! _,_

_[âˆ’]_ _[Ïƒ][2]_ _[âˆ’]_ _[Ïƒ][2]_

where the sign < or > is choosed according to the inequality between Ïƒ0 and Ïƒ1.


_Proof. Assume first Ïƒ0 > Ïƒ1. Let us shift the coordinates, such that x +_ _Ïƒ0[2]Ïƒ[âˆ’]0[2][Ïƒ]1[2]_ _[Î´][ â†]âˆ’_ 0. Now, the x

will have coordinates âˆ’ _Ïƒ0[2]Ïƒ[âˆ’]0[2][Ïƒ]1[2]_ _[Î´][. Assume][ X][ âˆ¼N]_ [(][âˆ’] _Ïƒ0[2]Ïƒ[âˆ’]0[2][Ïƒ]1[2]_ _[Î´, Ïƒ]0[2][I][)][. To obtain]_

P0(B) = P(X _B) = P_ _X_ _<_ _Ïƒ0[2][Ïƒ]1[2]_ _Ïƒ0[2][Ïƒ]1[2]_ log _Ïƒ0_ + [2][Ïƒ]0[2][Ïƒ]1[2] log(r)
_âˆˆ_ _âˆ¥_ _âˆ¥[2]_ (Ïƒ0[2] 1[)][2][ âˆ¥][Î´][âˆ¥][2][ + 2][N] _Ïƒ0[2]_ 1 _Ïƒ1_ _Ïƒ0[2]_ 1
  

_[âˆ’]_ _[Ïƒ][2]_ _[âˆ’]_ _[Ïƒ][2]_ _[âˆ’]_ _[Ïƒ][2]_


-----

we could almost use NCCHSQ, but we donâ€™t have correct scaling of variance of X. However, for
any regular square matrix Q, it follows that P(X _B) = P(QX_ _QB), where QB is interpreted_
1 âˆˆ _âˆˆ_
as set projection. Therefore, if we choose Q â‰¡ _Ïƒ0_ _[I][, we will get]_

P0(B) = P _X/Ïƒ0_ _<_ _Ïƒ1[2]_ _Ïƒ1[2]_ log _Ïƒ0_ + 2Ïƒ1[2] log(r) _._
_âˆ¥_ _âˆ¥[2]_ (Ïƒ0[2] 1[)][2][ âˆ¥][Î´][âˆ¥][2][ + 2][N] _Ïƒ0[2]_ 1 _Ïƒ1_ _Ïƒ0[2]_ 1
   

Now, since X/Ïƒ0 âˆ¼N (âˆ’ _Ïƒ0[2]Ïƒ[âˆ’]0[Ïƒ]1[2]_ _[Î´, I][âˆ’][)][,][Ïƒ][ we can use the definition of NCCHSQ to obtain the final:][2]_ _[âˆ’]_ _[Ïƒ][2]_ _[âˆ’]_ _[Ïƒ][2]_

P0(B) = Ï‡[2]N (Ïƒ0[2] _Ïƒ0[2]_ 1[)][2][ âˆ¥][Î´][âˆ¥][2][,] (Ïƒ0[2] _Ïƒ1[2]_ 1[)][2][ âˆ¥][Î´][âˆ¥][2][ + 2][N] _Ïƒ0[2]_ _Ïƒ1[2]_ 1 log _ÏƒÏƒ01_ + _Ïƒ0[2]2Ïƒ1[2]_ 1 log(r) _._

   

_[âˆ’]_ _[Ïƒ][2]_ _[âˆ’]_ _[Ïƒ][2]_ _[âˆ’]_ _[Ïƒ][2]_ _[âˆ’]_ _[Ïƒ][2]_

To obtain P1(B), we will do similar calculation, yet we need to compute the offset:

_x +_ _Ïƒ0[2]_ _Î´_ _x_ _Î´ =_ _Ïƒ1[2]_ _a._

_Ïƒ0[2]_ 1 _âˆ’_ _âˆ’_ _Ïƒ0[2]_ 2

_[âˆ’]_ _[Ïƒ][2]_ _[âˆ’]_ _[Ïƒ][2]_

Thus, after shifting coordinates in the same way, our alternative X will be distributed like
_X âˆ¼N_ (âˆ’ _Ïƒ0[2]Ïƒ[âˆ’]1[2][Ïƒ]2[2]_ _[a, Ïƒ][1][I][)][. Now, the same idea as before will yield the required formula.]_

In the case of Ïƒ0 < Ïƒ1, we do practically the same thing, yet now, we have to keep in mind, that B
will not be a ball, but its complement, therefore we will obtain â€œ1âˆ’â€ in the formulas.

**Lemma 18. Functions Î¾>(a), Î¾<(a) are continuous on the whole R+. Particularly, they are contin-**
uous at 0.

_Proof. Assume for simplicity Ïƒ0 > Ïƒ1 and fix x0, whose position is irrelevant and fix x1 such that_
_âˆ¥x0 âˆ’_ _x1âˆ¥_ = am, where am is the point, where we prove the continuity. Note, that Ï‡[2]N [(][Î», x][)][ can be]
interpreted (as we have seen) as a probability of an offset ball with radius _x and offset_ _âˆšÎ». Assume_

_[âˆš]_

we have a sequence {ai}i[âˆž]=1 _[, a][i][ âˆ’]â†’_ _am. Define xi to be a point lying on the line defined by x0, x1_
loss of generality, we can assume, that alls.t. âˆ¥x0 âˆ’ _xiâˆ¥_ = ai. define Bai to be the worst-case ball corresponding to Bâ€™s are open. We have already seen from Lemma 2, that ai, xi. Now, without
centers of Bi converge to the center of Bm. Define Xi = 1(Bi), Xm = 1(Bm).

First we need to prove, that ri, radiuses of the balls converge. Assume for contradiction, that ri

see, thatdo not converge. Without loss of gererality, let P0(Bi) Ì¸= pB for some i for which ri is too big. If rs = lim supiâˆ’â†’âˆž rsr <i > r âˆž, considerm. If rs = { âˆžaik, it is trivial to}k[âˆž]=0 [to be the]
subsequence for which rs is monotonically attained. Define Bs the ball with center x1 and radius
_a.s._
_rs and Xs = 1(Bs). Then, Xik_ _âˆ’â†’_ _Xs for k âˆ’â†’âˆž_ and from dominated convergence theorem,
P0(Bik ) âˆ’â†’ P0(Bs). However, P0(Bs) > P0(Bm) = pB, what is contradiction, since obviously
P0(Bik ) Ì¸= pB for some k.

Since Ïƒ1 is fixed, the P1i, probability measures corresponding to N (xi, Ïƒ1I) are actually the same
probability measure up to a shift. Therefore, P1i (Bi) can be treated as P2( B[Â¯]i), where P2 is simply
measure corresponding to N (0, Ïƒ1I) and _B[Â¯]i is simply Bi shifted accordingly s.t. P1i_ (Bi) = P2( B[Â¯]i)
(and assume, without loss of generality, that for each i, they are shifted such that their centers lie
on a fixed line). Now, since we know, that â€œpositionâ€ of both the centers of the balls and the x1 is
continuous w.r.t a, as can be seen from Lemma 2 (and the radiuses are still ri and converge), we see,
that even 1( B[Â¯]i) **1( B[Â¯]m) almost surely. Now, we can simply use dominated convergence theorem**
_âˆ’â†’_
using P2 to obtain P2( B[Â¯]i) âˆ’â†’ P2( B[Â¯]m) and thus P1i (Bi) âˆ’â†’ P1m (Bm), what we wanted to prove.

Note that the proof for the case Ïƒ0 < Ïƒ1 is fully analogous, yet instead of class B probabilities, we
work with class A probabilities to still work with balls and not with less convenient complements.

**Lemma 19. If Î»1 > Î»2, then Ï‡[2]N** [(][Î»]1[2][, x][2][)][ â‰¤] _[Ï‡][2]N_ [(][Î»]2[2][, x][2][)][.]

_Proof. Let us fix N_ (0, I) and respective measure P and respective density f . From symmetry, the
NCCHCSQ defined as distribution of âˆ¥Xâˆ¥[2] for an offset normal distribution can be as well defined
as âˆ¥X âˆ’ _sâˆ¥[2]_ under centralized normal distribution. Define B1 a ball with center at (Î»1, 0, . . ., 0)
and radius x and B2 a ball with center at (Î»2, 0, . . ., 0) and radius x. Denote C(B) as the center


-----

of a ball B. From definition of NCCHSQ it now follows, that P(Bi) = Ï‡[2]N [(][Î»]i[2][, x][2][)][, i][ âˆˆ{][1][,][ 2][}][.]
Therefore, it suffices to show P(B1) â‰¤ P(B2).

Define D1 = B1\B2 and D2 = B2\B1. Then we know:


P(B1) =

_BZ1_

P(B2) =

_BZ2_


_f_ (z)dz =

_B1Zâˆ©B2_

_f_ (z)dz =

_B2Zâˆ©B1_


_f_ (z)dz +

_B1Z\B2_

_f_ (z)dz +

_B2Z\B1_


_f_ (z)dz =

_B1Zâˆ©B2_

_f_ (z)dz =

_B2Zâˆ©B1_


_f_ (z)dz +

_DZ1_

_f_ (z)dz +

_DZ2_


_f_ (z)dz

_f_ (z)dz.


Thus,


P(B1) â‰¤ P(B2) â‡


_f_ (z)dz â‰¤


_f_ (z)dz.


_D1_


_D2_


Let S = _[C][(][B][1][)+]2_ _[C][(][B][2][)]_ . Define a central symmetry M with center S. Let z1 _D1. Then z1 can be_

decomposed as z1 = C(B1) + d, âˆ¥dâˆ¥â‰¤ _x. Then, z2 := M_ (z1) = C(B2) âˆ’ âˆˆd from symmetry. This
way, we see, that D1 = M (D2) and D2 = M (D1) under a bijection M which does not distort the
geometry and distances of the euclidean space. Therefore, it suffices to show:

_âˆ€_ _z âˆˆ_ _D2 : f_ (z) â‰¥ _f_ (M (z)), M (z) âˆˆ _D1._

From the monotonicity of f (y) w.r.t _y_ it actually suffices to show _z_ _M_ (z) _z_ _D2. Fix_
_âˆ¥_ _âˆ¥_ _âˆ¥_ _âˆ¥â‰¤âˆ¥_ _âˆ¥âˆ€_ _âˆˆ_
some z _D2. By the fact that M is central symmetry and z_ _M_ (z), it is obvious, that z = S + p,
_âˆˆ_ _âˆ’â†’_
_M_ (z) = S âˆ’ _p, where p is some vector. Now, using law of cosine, we can write:_

_âˆ¥zâˆ¥[2]_ = âˆ¥Sâˆ¥[2] + âˆ¥pâˆ¥[2] _âˆ’_ 2âˆ¥Sâˆ¥âˆ¥pâˆ¥ cos(Î±),

where Î± is angle between S and âˆ’p. On the other hand:

_âˆ¥M_ (z)âˆ¥[2] = âˆ¥Sâˆ¥[2] + âˆ¥âˆ’pâˆ¥[2] _âˆ’_ 2âˆ¥Sâˆ¥âˆ¥âˆ’pâˆ¥ cos(Ï€ âˆ’ _Î±)._

It is obvious from these equations, that

_âˆ¥zâˆ¥â‰¤âˆ¥M_ (z)âˆ¥â‡â‡’ _Î± â‰¤_ _Ï€/2 â‡â‡’_ _p[T]_ _S â‰¤_ 0.

Here, the crucial observation is, that D1 and D2 are separated by a hyperplane perpendicular to S
(vector), such that S (point) is in this hyperplane. From this it follows:

_y âˆˆ_ _D2 =â‡’_ _y[T]_ _S â‰¤âˆ¥Sâˆ¥[2], y âˆˆ_ _D1 =â‡’_ _y[T]_ _S â‰¥âˆ¥Sâˆ¥[2]._


Now, since z = S + _p and z_ _D2, this implies_ _S_ _z[T]_ _S =_ _S_ + _p[T]_ _S and thus p[T]_ _S_ 0.
_âˆˆ_ _âˆ¥_ _âˆ¥[2]_ _â‰¥_ _âˆ¥_ _âˆ¥[2]_ _â‰¤_

**Lemma 20. Functions Î¾>(a), Î¾<(a) are non-decreasing in a.**

_Proof. First assume Ïƒ0 > Ïƒ1 and analyse Î¾>(a). From Lemma 18, we can without loss of generality_
assume, that a > 0, since Î¾>(0) is simply the limit for a 0 and cannot change the monotonicity
_âˆ’â†’_
status.

corresponding toNow, fix a > 0 x and define0, x1 and P x1 as usual. Choose0, x1 s.t. âˆ¥x0 âˆ’ Ïµ <x1âˆ¥ _Ïƒ=0[2]Ïƒ[âˆ’] a1[2][Ïƒ]1[2]. Denote[a][, which is the distance between] Ba to be the worst-case ball[ x][1][ and]_

_C(Ba), as can be seen from Lemma 2._

Now, assume x2 lies on line defined by x0, x1 with âˆ¥x0âˆ’x2âˆ¥ = a+Ïµ. Let Ba+Ïµ be the corresponding
worst-case ball andâˆ¥Second, note, that sincex2 âˆ’ _C(Ba)âˆ¥. Here we use P2 as usual. First observe, that Ba+Ïµ Ï‡ is the worst-case ball for[2]N_ [(][Î»][1][, x][)][ â‰¤] _[Ï‡][2]N_ [(][Î»][2][, x] P[)]2[ if] x(B2[ Î»], it followsa[1])[ > Î»] â‰¥ P[2]1[, what is proved in Lemma 19.](B Pa2)(, sinceBa+Ïµ) âˆ¥ â‰¥x1P âˆ’2(BCa(B). Thus,a)âˆ¥ _>_
P1(Ba) â‰¤ P2(Ba+Ïµ), but that is exactly Î¾>(a) â‰¤ _Î¾>(a + Ïµ)._

To prove Î¾>(a) â‰¤ _Î¾>(a + Ïµ) also for Ïµ >_ _Ïƒ0[2]Ïƒ[âˆ’]1[2][Ïƒ]1[2]_ _[a][, it suffices to consider finite sequence of points]_

_ai starting at a and ending at a + Ïµ that are â€œclose enough to each otherâ€ such that the respective Ïµi_
that codes the shift ai âˆ’â†’ _ai+1 satisfy Ïµi <_ _Ïƒ0[2]Ïƒ[âˆ’]1[2][Ïƒ]1[2]_ _[a][i][.]_


-----

Now, assume Ïƒ0 < Ïƒ1 and analysie Î¾<(a). The proof is similar, but we have to be a bit careful about
some details. Again, fix a > 0, define x0, x1 accordingly and all other objects as before, except
now, let us denote Aa = Ba[C] [and][ A][a][+][Ïµ] [=][ B]a[C] [to be the class][ A][ balls which are complements to the]
anti-ballsmonotonicity from Lemma 19. Moreover, B. Again, P2(Aa) â‰¤ P1(Aa), since P2 âˆ¥(Ax1a âˆ’+Ïµ)C â‰¤(APa2)âˆ¥(A<a âˆ¥), sincex2 âˆ’ _C B(Aa+aÏµ) is the worst-case setâˆ¥. We again used the_
for x2. Therefore, P1(Aa) â‰¥ P2(Aa+Ïµ), but after reverting to Bâ€™s, it follows Î¾>(a) â‰¤ _Î¾>(a + Ïµ)._

Here, we donâ€™t even need to care about âˆ¥Ïµâˆ¥, since the centers of Aâ€™s are on the opposite half-lines
from x0 than x1 and x2.

To prove the main theorem, we need a simple bound on a median of central chi-squared distribution,
shown in Robert (1990) in a more general way.
**Lemma 21. For all c â‰¥** 0,

_N âˆ’_ 1 + c â‰¤ _Ï‡[2]N,qf_ [(][c,][ 0][.][5)][ â‰¤] _[Ï‡][2]N,qf_ [(0][.][5) +][ c.]

_Proof. See Robert (1990)._

**Theorem 4 (the curse of dimensionality): Let x0, x1, pA, Ïƒ0, Ïƒ1, N be as usual. Then, the follow-**
ing two implications hold:


1. If Ïƒ0 > Ïƒ1 and

log _Ïƒ12_

_Ïƒ0[2]_



then x1 is not certified w.r.t. x0.


+ 1 1 _<_ [2 log(1][ âˆ’] _[p][A][)]_
_âˆ’_ _[Ïƒ]Ïƒ0[2][2]_ _N_


2. If Ïƒ0 < Ïƒ1 and

log _Ïƒ12_ _N âˆ’_ 1

_Ïƒ0[2]_ _N_



then x1 is not certified w.r.t. x0.


+ 1 1
_âˆ’_ _[Ïƒ]Ïƒ0[2][2]_


_N âˆ’_ 1


_<_ [2 log(1][ âˆ’] _[p][A][)]_


_xProof.1_ ). From monotonicity of We will first prove first statement, thus let us assume Î¾ showed in Lemma 20, we know Ïƒ0 Î¾ > Ïƒ>( _x10. Thenx1_ P) 1(BÎ¾) =>(0) Î¾. We will>(âˆ¥x0 âˆ’
showâˆ¥ _Î¾>(0) > 0.5. We have, using definition of Î¾> plugging in a = 0âˆ¥_ : _âˆ’_ _âˆ¥_ _â‰¥_

_Î¾>(0) = Ï‡[2]N_ _ÏƒÏƒ012[2]_ _Ï‡[2]N,qf_ [(1][ âˆ’] _[p][A][)]_ _._

 

Note, that here, we work with central chi-square cdf and quantile function. In order to show Î¾>(0) >
0.5, it suffices to show
_Ïƒ0[2]_ _Ï‡[2]N,qf_ [(1][ âˆ’] _[p][A][)][ â‰¥]_ _[N,]_

_Ïƒ1[2]_

because it is well-known, that median of central chi-square distribution is smaller than mean, which
is N, i.e. from strict monotonicity of cdf, we will get Ï‡[2]N [(][N] [)][ >][ 0][.][5][. To show the above inequal-]
ity, we will use Chernoff bound on chi-squared, which states the following: If 0 < z < 1, then
_Ï‡[2]N_ [(][zN] [)][ â‰¤] [(][z][ exp(1][ âˆ’] _[z][))][N/][2][. Putting][ z][ â‰¡]_ _[Ïƒ]Ïƒ10[2][2]_ [, using chernoff bound we get:]

_[N]_

_Ï‡[2]N_ _ÏƒÏƒ01[2]2_ _N_ _â‰¤_ _ÏƒÏƒ102[2]_ exp 1 âˆ’ _Ïƒ[Ïƒ]01[2][2]_ 2 _<!_ 1 âˆ’ _pA._

    

The last inequality is required to hold. If it holds, then necessarily Ï‡[2]N,qf [(1][ âˆ’] _[p][A][)][ >][ Ïƒ]Ïƒ10[2][2]_ _[N][ and thus]_

_Ïƒ0[2]_

_Ïƒ1[2]_ _[Ï‡]N,qf[2]_ [(1][ âˆ’] _[p][A][)][ > N.][ Manipulating the required inequality, we will get exactly]_

log _Ïƒ12_ + 1 1 _<_ [2 log(1][ âˆ’] _[p][A][)]_ _,_

_Ïƒ0[2]_ _âˆ’_ _[Ïƒ]Ïƒ0[2][2]_ _N_

 

what is the assumption of 1.


-----

Similarly we will also prove the statement 2. Assume Ïƒ0 > Ïƒ1. Like in part 1, we will just prove
_Î¾<(0) > 0.5 by using chernoff bound. This time, however, we have:_


_Ïƒ02_ _Ï‡[2]N,qf_ [(][p][A][)]

_Ïƒ1[2]_




_Î¾<(0) = 1_ _Ï‡[2]N_
_âˆ’_


i.e. we need to prove


_Ïƒ02_ _Ï‡[2]N,qf_ [(][p][A][)] _<_ [1]

_Ïƒ1[2]_ 2 _[.]_

 


_Ï‡[2]N_


The second part of Chernoff bound states: If 1 < z, then Ï‡[2]N [(][zN] [)][ â‰¥] [1][ âˆ’] [(][z][ exp(1][ âˆ’] _[z][))][N/][2][. Let us]_

choose z â‰¡ _[Ïƒ]Ïƒ10[2][2]_ _NNâˆ’1_ [. Then Chernoff bound yields:]

_Ï‡[2]N_ _ÏƒÏƒ10[2]2_ _N âˆ’N_ 1 _N_ _â‰¥_ 1 âˆ’ _ÏƒÏƒ01[2]2_ _N âˆ’N_ 1 exp 1 âˆ’ _Ïƒ[Ïƒ]01[2][2]_ _N âˆ’N_ 1 _> p!_ _A._

    

If this holds, then

_Ïƒ1[2]_ _N âˆ’_ 1 _N > Ï‡[2]N,qf_ [(][p][A][)][ â‡] 0 _Ï‡[2]N,qf_ [(][p][A][)][ < N][ âˆ’] [1][.]

_Ïƒ0[2]_ _N_ _â‡’_ _Ïƒ[Ïƒ]1[2][2]_

Now, using Lemma 21 for the easy case of central chi-squared, we see: Ï‡[2]N [(][N][ âˆ’] [1)][ <][ 0][.][5][ and thus]

_Ï‡[2]N_ _Ïƒ02_ _Ï‡[2]N,qf_ [(][p][A][)] _<_ [1]

_Ïƒ1[2]_ 2 _[,]_

 

what we wanted to prove.

**Corollary 5 (one-sided simpler bound): Let x0, x1, pA, Ïƒ0, Ïƒ1, N be as usual and assume now**
_Ïƒ0 > Ïƒ1. Then, if_


log(1 _pA)_
_âˆ’_ _âˆ’_


_Ïƒ1_
_Ïƒ0_


1 âˆ’ 2


then x1 is not certified w.r.t x0.

_Proof. We will simply prove_


log _Ïƒ12_
_â‡’_ _Ïƒ0[2]_



+ 1 1 _<_ [2 log(1][ âˆ’] _[p][A][)]_
_âˆ’_ _Ïƒ[Ïƒ]0[2][2]_ _N_


log(1 _pA)_
_âˆ’_ _âˆ’_


_Ïƒ1_
_Ïƒ0_


1 âˆ’ 2


Assume expression log(1âˆ’y)+y; 1 > y > 0. From Taylor series, it is apparent, that log(1âˆ’y)+y <

2 [. Therefore, if][ âˆ’] _[y]2[2]_ _[<][ 2 log(1]N[âˆ’][p][A][)]_, then also log(1 _y) + y <_ [2 log(1]N[âˆ’][p][A][)] . Solving for y in the

_âˆ’_ _[y][2]_ _âˆ’_

log(1 _pA)_ 1

first inequality, we get sufficient condition y > 2 _âˆ’_ _Nâˆ’_ . Plugging 1 âˆ’ _[Ïƒ]Ïƒ0[2][2]_ [into][ y][ we get:]
q


1 1 _> 2_
_âˆ’_ _Ïƒ[Ïƒ]0[2][2]_


log(1 _pA)_
_âˆ’_ _âˆ’_


which is very easily manipulated to the inequality from theorem statement.

statements hold:Theorem 6: Let x0, x1, pA, Ïƒ0 be as usual and let âˆ¥x0 âˆ’ _x1âˆ¥_ = R. Then, the following two

1. Let Ïƒ1 â‰¤ _Ïƒ0. Then, for all Ïƒ2 : Ïƒ1 â‰¤_ _Ïƒ2 â‰¤_ _Ïƒ0, if Î¾>(R, Ïƒ2) > 0.5, then Î¾>(R, Ïƒ1) > 0.5._

2. Let Ïƒ1 â‰¥ _Ïƒ0. Then, for all Ïƒ2 : Ïƒ1 â‰¥_ _Ïƒ2 â‰¥_ _Ïƒ0, if Î¾<(R, Ïƒ2) > 0.5, then Î¾>(R, Ïƒ1) > 0.5._


-----

_Proof. We will first prove the first statement. Denote, as usual in the proofs Bi the worst-case ball_
for Ïƒi, Pi the probability associated to N (x1, Ïƒi[2][I][)][. Since][ Î¾][>][(][R, Ïƒ][2][)][ >][ 0][.][5][ and since it is essentially]
P2(B2), we see, that the probability of a ball under normal distribution is bigger than half. This is
_Î¾obviously possible just if>(R, Ïƒ1) = P1(B1) â‰¥_ P x1(1B âˆˆ2). It suffices to showB2. From the fact, that P1(B B2) â‰¥1 is the worst-case ball forP2(B2). _Ïƒ1 we see_

This follows, since Ïƒ1 â‰¤ _Ïƒ2 and x1 âˆˆ_ _B2. We know, that we can rescale the space such that_

_Ïƒ2_

P1(B2) = P2 (B2 _x1) + x1_ _,_

_Ïƒ1_ _âˆ’_

 

using the fact that Ïƒ just scales the normal distribution. The set _[Ïƒ]Ïƒ[2]1_ [(][B][2][ âˆ’] _[x][1][) +][ x][1][ is just an image]_

of B2 via homothety with center x1 and rate _[Ïƒ]Ïƒ[2]1_ [. So it suffices to prove]

_Ïƒ2_

P2 (B2 _x1) + x1_ P2(B2).

_Ïƒ1_ _âˆ’_ _â‰¥_

 

However, obviously _Ïƒ[Ïƒ]1[2]_ [(][B][2][ âˆ’] _[x][1][) +][ x][1][ âŠƒ]_ _[B][2][ from convexity of a ball. If, namely,][ x][1][ +][ z][ âˆˆ]_ _[B][2][,]_

then from convexity also x1 + _[Ïƒ]Ïƒ[1]2_ _[z][ âˆˆ]_ _[B][2][ and this maps back to][ x][1][ +][ z][, thus][ x][1][ +][ z][ is in an image.]_

Applying monotonicity of P, we obtain the result.

Now we will prove the second statement and as usual, let A1, A2, P1, P2 be as usual (A is now the
ball connected to class A). As always, P1(A1) â‰¤ P1(A2), so it suffices to show P2(A2) < 0.5 =â‡’
Panalogical to the first part, but now reasoning on1(A2) < 0.5. Now, we need to distinguish two cases. If Aâ€™s rather than x1 âˆˆ Bâ€™s. In this case, we will evenA2, the proof is completely
get strongerindeed P2(A P2)1 <(A 02.)5 â‰¤, yet it is also obvious to see thatP2(A2) just like in the first part. If P1(A2 x) <1 Ì¸âˆˆ 0.5A. This finishes the proof of the2, then it is easy to see, that
lemma.

**Theorem 7: Let Ïƒ(x) be r-semi-elastic function and x0, pA, N, Ïƒ0 as usual. Then, the certified**
radius at x0 guaranteed by our method is

_CR(x0) = max {0, sup {R â‰¥_ 0; Î¾>(R, Ïƒ0 exp(âˆ’rR)) < 0.5 and Î¾<(R, Ïƒ0 exp(rR)) < 0.5}} .

_Proof. This follows easily from Theorem 6_


**Lemma 22. Let us have f** (x) = _i=1_ _fi(x)1(x âˆˆ_ _Ri), where {Ri}i[M]=1_ [is finite set of regions that]

divide the R[N] and {fi}i[M]=1[, f][i][ :][ R]P[i][ âˆ’]â†’ R is finite set of 1-Lipschitz continuous (1-LC) functions.
Moreover assume, that f (x) is continuous. Then, f (x) is 1-LC.

_Proof. We do not assume any nice behaviour from our decision regions, what can make the situation_
quite ugly. For instance, regions might not be measurable. However, it will not be a problem for us.

Fixwork with numbers in x1, x2. Consider line segment [0, 1] via the S Î± = encoding. Consider the following coloring x1 + Î±(x2 âˆ’ _x1), Î± âˆˆ_ [0, 1]. Let us instead of points in C of [0, 1]: Each S
numbers colored the same color asbelongs. Definepoint a âˆˆ [0, 1] will be assigned one of d1 â‰¡ 0 and d2 = sup 0. Then,{z M âˆˆ colors according to which region the[0, 1], C(z) = C(d1)}. Thus, d2 is the supremum of all x1 + a(x2 âˆ’ _x1)_

_|f_ (x1 + d2(x2 âˆ’ _x1)) âˆ’_ _f_ (x1 + d1(x2 âˆ’ _x1))| â‰¤_ (d2 âˆ’ _d1)âˆ¥x2 âˆ’_ _x1âˆ¥._

Why? Let {zj}j[âˆž]=1 [be a non-decreasing sequence s.t.][ C][(][z][j][) =][ C][(0)][ and][ z][j][ âˆ’]â†’ _d2. Since f is_
continuous, obviously f (x1 + d2(x2 _x1)) = lim_
_j_
_âˆ’_ _âˆ’â†’âˆž[f]_ [(][x][1][ +][ z][j][(][x][2][ âˆ’] _[x][1][))][. Now, since norm and]_

absolute value are both continuous functions and since from 1-LC of fC(0) on RC(0) we have


_j_ N : 1,
_âˆ€_ _âˆˆ_ _[|][f]_ [(][x][1][ +][ z][j][(][x][2]([ âˆ’]zj _[x][1]d[))]1[ âˆ’])_ _x[f]2[(][x][1][ +]x1[ d][1][(][x][2][ âˆ’]_ _[x][1][))][|]_ _â‰¤_

_âˆ’_ _âˆ¥_ _âˆ’_ _âˆ¥_

we also necessarily have

_f_ (x1 + d2(x2 _x1))_ _f_ (x1 + d1(x2 _x1))_
_|_ _âˆ’_ _âˆ’_ _âˆ’_ _|_ 1.

(d2 _d1)_ _x2_ _x1_ _â‰¤_
_âˆ’_ _âˆ¥_ _âˆ’_ _âˆ¥_


-----

If d2 = 1, we finish the construction. If not, distinguish two cases. First assume C(d2) = C(d1). In
this case, take some color C s.t.
_zj_ _j=1_ [:][ z][j][+1] _d2 and zj > d2_ _j_ N,
_âˆƒ{_ _}[âˆž]_ _[â‰¤]_ _[z][j]_ _[âˆ€][j][ âˆˆ]_ [N][ and][ z][j] _â†’[âˆ’]_ _âˆ€_ _âˆˆ_
and fix one such {zj}j[âˆž]=1[. Obviously,][ C][ Ì¸][=][ C][(0)][,][ since][ d][2][ is upper-bound on points of color]
_C(0). Then, define d3 = sup{z âˆˆ_ [0, 1], C(z) = C} and also define {zj}j[âˆž]=1 [:][ z][j][+1][ â‰¥] _[z][j][ âˆ€][j][ âˆˆ]_
N and zj _d3. From continuity of f_, we again have f (x1 + _d2(x2_ _x1)) = lim_
_âˆ’â†’_ _âˆ’_ _jâˆ’â†’âˆž[f]_ [(][x][1][ +] _[z][j][(][x][2][ âˆ’]_

_x1)) and similarly f_ (x1 + d3(x2 _x1)) = lim_
_j_
_âˆ’_ _âˆ’â†’âˆž[f]_ [(][x][1][ +][ z][j][(][x][2][ âˆ’] _[x][1][))][. Again from continuity of]_

absolute value and norm and 1-LC of all the partial functions we have:

_j_ N : 1
_âˆ€_ _âˆˆ_ _[|][f]_ [(][x][1][ +][ z][j][(][x][2]([ âˆ’]zj _[x][1]z[))]j)[ âˆ’]x[f]2[(][x][1]x[ +]1_ _[ z][j][(][x][2][ âˆ’]_ _[x][1][))][|]_ _â‰¤_

_âˆ’_ _âˆ¥_ _âˆ’_ _âˆ¥_

and
_f_ (x1 + d3(x2 _x1))_ _f_ (x1 + d2(x2 _x1))_
_|_ _âˆ’_ _âˆ’_ _âˆ’_ _|_ 1.

(d3 _d2)_ _x2_ _x1_ _â‰¤_
_âˆ’_ _âˆ¥_ _âˆ’_ _âˆ¥_

Now assume C(d2) = C(d1). Then, we can take as C directly C(d2) and do the same as in the last
_Ì¸_
paragraph (note, that this case could have implicitly come up in the previous construction too, but
we would need to not take C = C(0) and we find this case distinction to be more elegant).

If d3 = 1, we finish the construction. If not, we continue in exactly the same manner as before.
Since the number of colors M is finite, we will run out of colors in finite number of steps and thus,
eventually there will be l â‰¤ _M s.t. dl = 1. The final 1-LC is now trivially obtained as follows:_

_lâˆ’1_

_|f_ (x1 + 1(x2 âˆ’ _x1)) âˆ’_ _f_ (x1 + 0(x2 âˆ’ _x1))| =_ _i=1_ _f_ (x1 + di+1(x2 âˆ’ _x1)) âˆ’_ _f_ (x1 + di(x2 âˆ’ _x1))_

X


_lâˆ’1_

_i=1_

X


_lâˆ’1_

_f_ (x1 + di+1(x2 âˆ’ _x1)) âˆ’_ _f_ (x1 + di(x2 âˆ’ _x1))_ _â‰¤_ _i=1_ (di+1 âˆ’ _di)âˆ¥x2 âˆ’_ _x1âˆ¥_

X

_lâˆ’1_

= _x2_ _x1_ (di+1 _di) =_ _x2_ _x1_
_âˆ¥_ _âˆ’_ _âˆ¥_ _i=1_ _âˆ’_ _âˆ¥_ _âˆ’_ _âˆ¥_

X


**Theorem 8: The Ïƒ(x) defined in Equation 1 is r-semi-elastic.**

_Proof. Our aim is to prove, that_

log(Ïƒ(x)) = log(Ïƒb) + r _x_ _xi_ _m_

ï£« _k_ ï£« _âˆ¥_ _âˆ’_ _âˆ¥ï£¶_ _âˆ’_ ï£¶

_xiâˆˆNXk(x)_

is r lipschitz continuous. Obviously, this does not depend neither onï£­ [1] ï£­ log(ï£¸ _Ïƒb)ï£¸, nor on_ _rm, so we_
_âˆ’_
will focus just on _k[r]_ _x_ _xi_ . Obviously, this function is r lipschitz continuous if and only

_xiâˆˆNk(x)âˆ¥_ _âˆ’_ _âˆ¥_

if _k[1]_ _x_ _xi_ is 1-LC.P

_xiâˆˆNk(x)âˆ¥_ _âˆ’_ _âˆ¥_

P

Let us fix y âˆˆ R[N] . We will first prove âˆ¥x âˆ’ _yâˆ¥_ is 1-LC. Let us fix x1, x2. From triangle inequality
we have
_x1_ _y_ _x2_ _y_ _x1_ _x2_ _,_
_âˆ¥_ _âˆ’_ _âˆ¥âˆ’âˆ¥_ _âˆ’_ _âˆ¥_ _â‰¤âˆ¥_ _âˆ’_ _âˆ¥_
what is exactly what we wanted to prove.

Now fix y1, y2, . . ., yk and x1, x2. Then


_k_

_x1_ _yi_
_i=1âˆ¥_ _âˆ’_ _âˆ¥âˆ’_ _k[1]_

X


_k_ _k_

_x2_ _yi_ [= 1] _x1_ _yi_ _x2_ _yi_

_âˆ¥âˆ’_ _k[1]_ _i=1âˆ¥_ _âˆ’_ _âˆ¥_ _k_ _i=1âˆ¥_ _âˆ’_ _âˆ¥âˆ’âˆ¥_ _âˆ’_ _âˆ¥_

X X

_k_

_x1_ _yi_ _x2_ _yi_ _x1_ _x2_ = 1
_âˆ¥_ _âˆ’_ _âˆ¥âˆ’âˆ¥_ _âˆ’_ _âˆ¥_ _â‰¤_ _k[1]_ _i=1âˆ¥_ _âˆ’_ _âˆ¥_

X


_â‰¤_ _k[1]_


_i=1_


-----

Finally note, that using the k nearest neighbors out of finite training dataset will divide R[N] in a
finite number of regions, where each region is defined by the set of k nearest neighbors for x in that
region. Note, that the average distance from k nearest neighbors is obviously continuous. Then,
using Lemma 22, the claim follows.


-----

